{"mappings":"IcAI,EAIA,EACA,EAcA,EACA,EAGA,EACA,EAGA,EACA,EACA,ED5BA,EAIA,EAAY,EAQZ,EACA,EACA,EAEA,E,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,G,E,Q,S,C,C,C,E,E,E,O,C,mB,I,G,I,E,E,S,E,E,QXbG,OAAe,UAAyB,EAAA,cAAa,CA4C3D,YAAsB,CAAc,CAAE,CAAc,CAAE,CAAY,CAAE,CACnE,KAAK,CAAC,EAAQ,EAAU,CAAE,GAAG,CAAO,CAAE,SAAU,CAAA,CAAK,GA5C9C,IAAA,CAAA,WAAA,CAAc,MACd,IAAA,CAAA,YAAA,CAAe,IAAI,gBAA4B,CACtD,UAAW,CAAC,EAAO,KAClB,IAAK,IAAI,EAAQ,EAAG,EAAQ,EAAM,MAAM,CAAE,GAAS,IAAI,CAAC,WAAW,CAClE,EAAW,OAAO,CAAC,EAAM,QAAQ,CAAC,EAAO,EAAQ,IAAI,CAAC,WAAW,EAEnE,CACD,GACQ,IAAA,CAAA,cAAA,CAAiB,IAAI,eAA4B,CACxD,MAAO,MAAO,EAAO,KACpB,IAAM,EAAY,IAAI,QAAQ,AAAC,GAC9B,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,oBAAqB,EAAS,CAC/D,KAAM,CAAA,CACP,GAKD,OAAO,CAAA,IAAI,CAAC,WAAW,CAAC,cAAc,EACrC,AAAA,EAAA,cAAa,CAAE,mBAAmB,CAAG,EAAM,UAAU,EAAI,CAAA,EAG1D,GAAI,CACH,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,EACvB,CAAE,MAAO,EAAG,CACX,AAAA,CAAA,EAAA,EAAA,OAAK,AAAL,EAAO,KAAK,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,YAAY,CAAC,oBAAoB,C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","sources":["<anon>","node_modules/@parcel/node-resolver-core/lib/_empty.js","lib/dataconnection/StreamConnection/StreamConnection.ts","lib/logger.ts","lib/dataconnection/DataConnection.ts","lib/negotiator.ts","lib/enums.ts","lib/baseconnection.ts","lib/peerError.ts","node_modules/eventemitter3/index.js","lib/utils/randomToken.ts","lib/dataconnection/StreamConnection/Cbor.ts","node_modules/cbor-x/index.js","node_modules/cbor-x/encode.js","node_modules/cbor-x/decode.js","node_modules/cbor-x/iterators.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire83ac\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire83ac\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"5L6jO\", function(module, exports) {\n\"use strict\";\n\n});\n\nparcelRegister(\"hBa25\", function(module, exports) {\n\n$parcel$export(module.exports, \"StreamConnection\", () => $b68ef8ad985e69ce$export$72aa44612e2200cd);\n\nvar $aGTqB = parcelRequire(\"aGTqB\");\n\nvar $brJ7I = parcelRequire(\"brJ7I\");\nclass $b68ef8ad985e69ce$export$72aa44612e2200cd extends (0, $brJ7I.DataConnection) {\n    constructor(peerId, provider, options){\n        super(peerId, provider, {\n            ...options,\n            reliable: true\n        });\n        this._CHUNK_SIZE = 32768;\n        this._splitStream = new TransformStream({\n            transform: (chunk, controller)=>{\n                for(let split = 0; split < chunk.length; split += this._CHUNK_SIZE)controller.enqueue(chunk.subarray(split, split + this._CHUNK_SIZE));\n            }\n        });\n        this._rawSendStream = new WritableStream({\n            write: async (chunk, controller)=>{\n                const openEvent = new Promise((resolve)=>this.dataChannel.addEventListener(\"bufferedamountlow\", resolve, {\n                        once: true\n                    }));\n                // if we can send the chunk now, send it\n                // if not, we wait until at least half of the sending buffer is free again\n                await (this.dataChannel.bufferedAmount <= (0, $brJ7I.DataConnection).MAX_BUFFERED_AMOUNT - chunk.byteLength || openEvent);\n                // TODO: what can go wrong here?\n                try {\n                    this.dataChannel.send(chunk);\n                } catch (e) {\n                    (0, $aGTqB.default).error(`DC#:${this.connectionId} Error when sending:`, e);\n                    controller.error(e);\n                    this.close();\n                }\n            }\n        });\n        this.writer = this._splitStream.writable.getWriter();\n        this._rawReadStream = new ReadableStream({\n            start: (controller)=>{\n                this.once(\"open\", ()=>{\n                    this.dataChannel.addEventListener(\"message\", (e)=>{\n                        controller.enqueue(e.data);\n                    });\n                });\n            }\n        });\n        this._splitStream.readable.pipeTo(this._rawSendStream);\n    }\n    _initializeDataChannel(dc) {\n        super._initializeDataChannel(dc);\n        this.dataChannel.binaryType = \"arraybuffer\";\n        this.dataChannel.bufferedAmountLowThreshold = (0, $brJ7I.DataConnection).MAX_BUFFERED_AMOUNT / 2;\n    }\n}\n\n});\nparcelRegister(\"aGTqB\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $55e90223fe532944$export$2e2bcd8739ae039);\nconst $55e90223fe532944$var$LOG_PREFIX = \"PeerJS: \";\nvar $55e90223fe532944$export$243e62d78d3b544d;\n(function(LogLevel) {\n    /**\n\t * Prints no logs.\n\t */ LogLevel[LogLevel[\"Disabled\"] = 0] = \"Disabled\";\n    /**\n\t * Prints only errors.\n\t */ LogLevel[LogLevel[\"Errors\"] = 1] = \"Errors\";\n    /**\n\t * Prints errors and warnings.\n\t */ LogLevel[LogLevel[\"Warnings\"] = 2] = \"Warnings\";\n    /**\n\t * Prints all logs.\n\t */ LogLevel[LogLevel[\"All\"] = 3] = \"All\";\n})($55e90223fe532944$export$243e62d78d3b544d || ($55e90223fe532944$export$243e62d78d3b544d = {}));\nclass $55e90223fe532944$var$Logger {\n    get logLevel() {\n        return this._logLevel;\n    }\n    set logLevel(logLevel) {\n        this._logLevel = logLevel;\n    }\n    log(...args) {\n        if (this._logLevel >= 3) this._print(3, ...args);\n    }\n    warn(...args) {\n        if (this._logLevel >= 2) this._print(2, ...args);\n    }\n    error(...args) {\n        if (this._logLevel >= 1) this._print(1, ...args);\n    }\n    setLogFunction(fn) {\n        this._print = fn;\n    }\n    _print(logLevel, ...rest) {\n        const copy = [\n            $55e90223fe532944$var$LOG_PREFIX,\n            ...rest\n        ];\n        for(const i in copy)if (copy[i] instanceof Error) copy[i] = \"(\" + copy[i].name + \") \" + copy[i].message;\n        if (logLevel >= 3) console.log(...copy);\n        else if (logLevel >= 2) console.warn(\"WARNING\", ...copy);\n        else if (logLevel >= 1) console.error(\"ERROR\", ...copy);\n    }\n    constructor(){\n        this._logLevel = 0;\n    }\n}\nvar $55e90223fe532944$export$2e2bcd8739ae039 = new $55e90223fe532944$var$Logger();\n\n});\n\nparcelRegister(\"brJ7I\", function(module, exports) {\n\n$parcel$export(module.exports, \"DataConnection\", () => $f7363ab6888d1e18$export$d365f7ad9d7df9c9);\n\nvar $aGTqB = parcelRequire(\"aGTqB\");\n\nvar $eEr5Q = parcelRequire(\"eEr5Q\");\n\nvar $3pPW3 = parcelRequire(\"3pPW3\");\n\nvar $kRc3N = parcelRequire(\"kRc3N\");\n\nvar $9Ek5E = parcelRequire(\"9Ek5E\");\nclass $f7363ab6888d1e18$export$d365f7ad9d7df9c9 extends (0, $kRc3N.BaseConnection) {\n    static #_ = this.ID_PREFIX = \"dc_\";\n    static #_1 = this.MAX_BUFFERED_AMOUNT = 8388608;\n    get type() {\n        return (0, $3pPW3.ConnectionType).Data;\n    }\n    constructor(peerId, provider, options){\n        super(peerId, provider, options);\n        this.connectionId = this.options.connectionId || $f7363ab6888d1e18$export$d365f7ad9d7df9c9.ID_PREFIX + (0, $9Ek5E.randomToken)();\n        this.label = this.options.label || this.connectionId;\n        this.reliable = !!this.options.reliable;\n        this._negotiator = new (0, $eEr5Q.Negotiator)(this);\n        this._negotiator.startConnection(this.options._payload || {\n            originator: true,\n            reliable: this.reliable\n        });\n    }\n    /** Called by the Negotiator when the DataChannel is ready. */ _initializeDataChannel(dc) {\n        this.dataChannel = dc;\n        this.dataChannel.onopen = ()=>{\n            (0, $aGTqB.default).log(`DC#${this.connectionId} dc connection success`);\n            this._open = true;\n            this.emit(\"open\");\n        };\n        this.dataChannel.onmessage = (e)=>{\n            (0, $aGTqB.default).log(`DC#${this.connectionId} dc onmessage:`, e.data);\n        // this._handleDataMessage(e);\n        };\n        this.dataChannel.onclose = ()=>{\n            (0, $aGTqB.default).log(`DC#${this.connectionId} dc closed for:`, this.peer);\n            this.close();\n        };\n    }\n    /**\n\t * Exposed functionality for users.\n\t */ /** Allows user to close connection. */ close(options) {\n        if (options?.flush) {\n            this.send({\n                __peerData: {\n                    type: \"close\"\n                }\n            });\n            return;\n        }\n        if (this._negotiator) {\n            this._negotiator.cleanup();\n            this._negotiator = null;\n        }\n        if (this.provider) {\n            this.provider._removeConnection(this);\n            this.provider = null;\n        }\n        if (this.dataChannel) {\n            this.dataChannel.onopen = null;\n            this.dataChannel.onmessage = null;\n            this.dataChannel.onclose = null;\n            this.dataChannel = null;\n        }\n        if (!this.open) return;\n        this._open = false;\n        super.emit(\"close\");\n    }\n    /** Allows user to send data. */ send(data, chunked = false) {\n        if (!this.open) {\n            this.emitError((0, $3pPW3.DataConnectionErrorType).NotOpenYet, \"Connection is not open. You should listen for the `open` event before sending messages.\");\n            return;\n        }\n        return this._send(data, chunked);\n    }\n    async handleMessage(message) {\n        const payload = message.payload;\n        switch(message.type){\n            case (0, $3pPW3.ServerMessageType).Answer:\n                await this._negotiator.handleSDP(message.type, payload.sdp);\n                break;\n            case (0, $3pPW3.ServerMessageType).Candidate:\n                await this._negotiator.handleCandidate(payload.candidate);\n                break;\n            default:\n                (0, $aGTqB.default).warn(\"Unrecognized message type:\", message.type, \"from peer:\", this.peer);\n                break;\n        }\n    }\n}\n\n});\nparcelRegister(\"eEr5Q\", function(module, exports) {\n\n$parcel$export(module.exports, \"Negotiator\", () => $ee2f7acfd22ad8cb$export$89e6bb5ad64bf4a);\n\nvar $aGTqB = parcelRequire(\"aGTqB\");\n\nvar $3pPW3 = parcelRequire(\"3pPW3\");\nclass $ee2f7acfd22ad8cb$export$89e6bb5ad64bf4a {\n    constructor(connection){\n        this.connection = connection;\n    }\n    /** Returns a PeerConnection object set up correctly (for data, media). */ startConnection(options) {\n        const peerConnection = this._startPeerConnection();\n        // Set the connection's PC.\n        this.connection.peerConnection = peerConnection;\n        if (this.connection.type === (0, $3pPW3.ConnectionType).Media && options._stream) this._addTracksToConnection(options._stream, peerConnection);\n        // What do we need to do now?\n        if (options.originator) {\n            const dataConnection = this.connection;\n            const config = {\n                ordered: !!options.reliable\n            };\n            const dataChannel = peerConnection.createDataChannel(dataConnection.label, config);\n            dataConnection._initializeDataChannel(dataChannel);\n            this._makeOffer();\n        } else this.handleSDP(\"OFFER\", options.sdp);\n    }\n    /** Start a PC. */ _startPeerConnection() {\n        (0, $aGTqB.default).log(\"Creating RTCPeerConnection.\");\n        const peerConnection = new RTCPeerConnection(this.connection.provider.options.config);\n        this._setupListeners(peerConnection);\n        return peerConnection;\n    }\n    /** Set up various WebRTC listeners. */ _setupListeners(peerConnection) {\n        const peerId = this.connection.peer;\n        const connectionId = this.connection.connectionId;\n        const connectionType = this.connection.type;\n        const provider = this.connection.provider;\n        // ICE CANDIDATES.\n        (0, $aGTqB.default).log(\"Listening for ICE candidates.\");\n        peerConnection.onicecandidate = (evt)=>{\n            if (!evt.candidate || !evt.candidate.candidate) return;\n            (0, $aGTqB.default).log(`Received ICE candidates for ${peerId}:`, evt.candidate);\n            provider.socket.send({\n                type: (0, $3pPW3.ServerMessageType).Candidate,\n                payload: {\n                    candidate: evt.candidate,\n                    type: connectionType,\n                    connectionId: connectionId\n                },\n                dst: peerId\n            });\n        };\n        peerConnection.oniceconnectionstatechange = ()=>{\n            switch(peerConnection.iceConnectionState){\n                case \"failed\":\n                    (0, $aGTqB.default).log(\"iceConnectionState is failed, closing connections to \" + peerId);\n                    this.connection.emitError((0, $3pPW3.BaseConnectionErrorType).NegotiationFailed, \"Negotiation of connection to \" + peerId + \" failed.\");\n                    this.connection.close();\n                    break;\n                case \"closed\":\n                    (0, $aGTqB.default).log(\"iceConnectionState is closed, closing connections to \" + peerId);\n                    this.connection.emitError((0, $3pPW3.BaseConnectionErrorType).ConnectionClosed, \"Connection to \" + peerId + \" closed.\");\n                    this.connection.close();\n                    break;\n                case \"disconnected\":\n                    (0, $aGTqB.default).log(\"iceConnectionState changed to disconnected on the connection with \" + peerId);\n                    break;\n                case \"completed\":\n                    peerConnection.onicecandidate = ()=>{};\n                    break;\n            }\n            this.connection.emit(\"iceStateChanged\", peerConnection.iceConnectionState);\n        };\n        // DATACONNECTION.\n        (0, $aGTqB.default).log(\"Listening for data channel\");\n        // Fired between offer and answer, so options should already be saved\n        // in the options hash.\n        peerConnection.ondatachannel = (evt)=>{\n            (0, $aGTqB.default).log(\"Received data channel\");\n            const dataChannel = evt.channel;\n            const connection = provider.getConnection(peerId, connectionId);\n            connection._initializeDataChannel(dataChannel);\n        };\n        // MEDIACONNECTION.\n        (0, $aGTqB.default).log(\"Listening for remote stream\");\n        peerConnection.ontrack = (evt)=>{\n            (0, $aGTqB.default).log(\"Received remote stream\");\n            const stream = evt.streams[0];\n            const connection = provider.getConnection(peerId, connectionId);\n            if (connection.type === (0, $3pPW3.ConnectionType).Media) {\n                const mediaConnection = connection;\n                this._addStreamToMediaConnection(stream, mediaConnection);\n            }\n        };\n    }\n    cleanup() {\n        (0, $aGTqB.default).log(\"Cleaning up PeerConnection to \" + this.connection.peer);\n        const peerConnection = this.connection.peerConnection;\n        if (!peerConnection) return;\n        this.connection.peerConnection = null;\n        //unsubscribe from all PeerConnection's events\n        peerConnection.onicecandidate = peerConnection.oniceconnectionstatechange = peerConnection.ondatachannel = peerConnection.ontrack = ()=>{};\n        const peerConnectionNotClosed = peerConnection.signalingState !== \"closed\";\n        let dataChannelNotClosed = false;\n        const dataChannel = this.connection.dataChannel;\n        if (dataChannel) dataChannelNotClosed = !!dataChannel.readyState && dataChannel.readyState !== \"closed\";\n        if (peerConnectionNotClosed || dataChannelNotClosed) peerConnection.close();\n    }\n    async _makeOffer() {\n        const peerConnection = this.connection.peerConnection;\n        const provider = this.connection.provider;\n        try {\n            const offer = await peerConnection.createOffer(this.connection.options.constraints);\n            (0, $aGTqB.default).log(\"Created offer.\");\n            if (this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform === \"function\") offer.sdp = this.connection.options.sdpTransform(offer.sdp) || offer.sdp;\n            try {\n                await peerConnection.setLocalDescription(offer);\n                (0, $aGTqB.default).log(\"Set localDescription:\", offer, `for:${this.connection.peer}`);\n                let payload = {\n                    sdp: offer,\n                    type: this.connection.type,\n                    connectionId: this.connection.connectionId,\n                    metadata: this.connection.metadata\n                };\n                if (this.connection.type === (0, $3pPW3.ConnectionType).Data) {\n                    const dataConnection = this.connection;\n                    payload = {\n                        ...payload,\n                        label: dataConnection.label,\n                        reliable: dataConnection.reliable,\n                        serialization: dataConnection.serialization\n                    };\n                }\n                provider.socket.send({\n                    type: (0, $3pPW3.ServerMessageType).Offer,\n                    payload: payload,\n                    dst: this.connection.peer\n                });\n            } catch (err) {\n                // TODO: investigate why _makeOffer is being called from the answer\n                if (err != \"OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer\") {\n                    provider.emitError((0, $3pPW3.PeerErrorType).WebRTC, err);\n                    (0, $aGTqB.default).log(\"Failed to setLocalDescription, \", err);\n                }\n            }\n        } catch (err_1) {\n            provider.emitError((0, $3pPW3.PeerErrorType).WebRTC, err_1);\n            (0, $aGTqB.default).log(\"Failed to createOffer, \", err_1);\n        }\n    }\n    async _makeAnswer() {\n        const peerConnection = this.connection.peerConnection;\n        const provider = this.connection.provider;\n        try {\n            const answer = await peerConnection.createAnswer();\n            (0, $aGTqB.default).log(\"Created answer.\");\n            if (this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform === \"function\") answer.sdp = this.connection.options.sdpTransform(answer.sdp) || answer.sdp;\n            try {\n                await peerConnection.setLocalDescription(answer);\n                (0, $aGTqB.default).log(`Set localDescription:`, answer, `for:${this.connection.peer}`);\n                provider.socket.send({\n                    type: (0, $3pPW3.ServerMessageType).Answer,\n                    payload: {\n                        sdp: answer,\n                        type: this.connection.type,\n                        connectionId: this.connection.connectionId\n                    },\n                    dst: this.connection.peer\n                });\n            } catch (err) {\n                provider.emitError((0, $3pPW3.PeerErrorType).WebRTC, err);\n                (0, $aGTqB.default).log(\"Failed to setLocalDescription, \", err);\n            }\n        } catch (err_1) {\n            provider.emitError((0, $3pPW3.PeerErrorType).WebRTC, err_1);\n            (0, $aGTqB.default).log(\"Failed to create answer, \", err_1);\n        }\n    }\n    /** Handle an SDP. */ async handleSDP(type, sdp) {\n        sdp = new RTCSessionDescription(sdp);\n        const peerConnection = this.connection.peerConnection;\n        const provider = this.connection.provider;\n        (0, $aGTqB.default).log(\"Setting remote description\", sdp);\n        const self = this;\n        try {\n            await peerConnection.setRemoteDescription(sdp);\n            (0, $aGTqB.default).log(`Set remoteDescription:${type} for:${this.connection.peer}`);\n            if (type === \"OFFER\") await self._makeAnswer();\n        } catch (err) {\n            provider.emitError((0, $3pPW3.PeerErrorType).WebRTC, err);\n            (0, $aGTqB.default).log(\"Failed to setRemoteDescription, \", err);\n        }\n    }\n    /** Handle a candidate. */ async handleCandidate(ice) {\n        (0, $aGTqB.default).log(`handleCandidate:`, ice);\n        try {\n            await this.connection.peerConnection.addIceCandidate(ice);\n            (0, $aGTqB.default).log(`Added ICE candidate for:${this.connection.peer}`);\n        } catch (err) {\n            this.connection.provider.emitError((0, $3pPW3.PeerErrorType).WebRTC, err);\n            (0, $aGTqB.default).log(\"Failed to handleCandidate, \", err);\n        }\n    }\n    _addTracksToConnection(stream, peerConnection) {\n        (0, $aGTqB.default).log(`add tracks from stream ${stream.id} to peer connection`);\n        if (!peerConnection.addTrack) return (0, $aGTqB.default).error(`Your browser does't support RTCPeerConnection#addTrack. Ignored.`);\n        stream.getTracks().forEach((track)=>{\n            peerConnection.addTrack(track, stream);\n        });\n    }\n    _addStreamToMediaConnection(stream, mediaConnection) {\n        (0, $aGTqB.default).log(`add stream ${stream.id} to media connection ${mediaConnection.connectionId}`);\n        mediaConnection.addStream(stream);\n    }\n}\n\n});\nparcelRegister(\"3pPW3\", function(module, exports) {\n\n$parcel$export(module.exports, \"ConnectionType\", () => $e07633d19f7426e9$export$3157d57b4135e3bc);\n$parcel$export(module.exports, \"PeerErrorType\", () => $e07633d19f7426e9$export$9547aaa2e39030ff);\n$parcel$export(module.exports, \"BaseConnectionErrorType\", () => $e07633d19f7426e9$export$7974935686149686);\n$parcel$export(module.exports, \"DataConnectionErrorType\", () => $e07633d19f7426e9$export$49ae800c114df41d);\n$parcel$export(module.exports, \"ServerMessageType\", () => $e07633d19f7426e9$export$adb4a1754da6f10d);\nvar $e07633d19f7426e9$export$3157d57b4135e3bc;\n(function(ConnectionType) {\n    ConnectionType[\"Data\"] = \"data\";\n    ConnectionType[\"Media\"] = \"media\";\n})($e07633d19f7426e9$export$3157d57b4135e3bc || ($e07633d19f7426e9$export$3157d57b4135e3bc = {}));\nvar $e07633d19f7426e9$export$9547aaa2e39030ff;\n(function(PeerErrorType) {\n    /**\n\t * The client's browser does not support some or all WebRTC features that you are trying to use.\n\t */ PeerErrorType[\"BrowserIncompatible\"] = \"browser-incompatible\";\n    /**\n\t * You've already disconnected this peer from the server and can no longer make any new connections on it.\n\t */ PeerErrorType[\"Disconnected\"] = \"disconnected\";\n    /**\n\t * The ID passed into the Peer constructor contains illegal characters.\n\t */ PeerErrorType[\"InvalidID\"] = \"invalid-id\";\n    /**\n\t * The API key passed into the Peer constructor contains illegal characters or is not in the system (cloud server only).\n\t */ PeerErrorType[\"InvalidKey\"] = \"invalid-key\";\n    /**\n\t * Lost or cannot establish a connection to the signalling server.\n\t */ PeerErrorType[\"Network\"] = \"network\";\n    /**\n\t * The peer you're trying to connect to does not exist.\n\t */ PeerErrorType[\"PeerUnavailable\"] = \"peer-unavailable\";\n    /**\n\t * PeerJS is being used securely, but the cloud server does not support SSL. Use a custom PeerServer.\n\t */ PeerErrorType[\"SslUnavailable\"] = \"ssl-unavailable\";\n    /**\n\t * Unable to reach the server.\n\t */ PeerErrorType[\"ServerError\"] = \"server-error\";\n    /**\n\t * An error from the underlying socket.\n\t */ PeerErrorType[\"SocketError\"] = \"socket-error\";\n    /**\n\t * The underlying socket closed unexpectedly.\n\t */ PeerErrorType[\"SocketClosed\"] = \"socket-closed\";\n    /**\n\t * The ID passed into the Peer constructor is already taken.\n\t *\n\t * :::caution\n\t * This error is not fatal if your peer has open peer-to-peer connections.\n\t * This can happen if you attempt to {@apilink Peer.reconnect} a peer that has been disconnected from the server,\n\t * but its old ID has now been taken.\n\t * :::\n\t */ PeerErrorType[\"UnavailableID\"] = \"unavailable-id\";\n    /**\n\t * Native WebRTC errors.\n\t */ PeerErrorType[\"WebRTC\"] = \"webrtc\";\n})($e07633d19f7426e9$export$9547aaa2e39030ff || ($e07633d19f7426e9$export$9547aaa2e39030ff = {}));\nvar $e07633d19f7426e9$export$7974935686149686;\n(function(BaseConnectionErrorType) {\n    BaseConnectionErrorType[\"NegotiationFailed\"] = \"negotiation-failed\";\n    BaseConnectionErrorType[\"ConnectionClosed\"] = \"connection-closed\";\n})($e07633d19f7426e9$export$7974935686149686 || ($e07633d19f7426e9$export$7974935686149686 = {}));\nvar $e07633d19f7426e9$export$49ae800c114df41d;\n(function(DataConnectionErrorType) {\n    DataConnectionErrorType[\"NotOpenYet\"] = \"not-open-yet\";\n    DataConnectionErrorType[\"MessageToBig\"] = \"message-too-big\";\n})($e07633d19f7426e9$export$49ae800c114df41d || ($e07633d19f7426e9$export$49ae800c114df41d = {}));\nvar $e07633d19f7426e9$export$89f507cf986a947;\n(function(SerializationType) {\n    SerializationType[\"Binary\"] = \"binary\";\n    SerializationType[\"BinaryUTF8\"] = \"binary-utf8\";\n    SerializationType[\"JSON\"] = \"json\";\n    SerializationType[\"None\"] = \"raw\";\n})($e07633d19f7426e9$export$89f507cf986a947 || ($e07633d19f7426e9$export$89f507cf986a947 = {}));\nvar $e07633d19f7426e9$export$3b5c4a4b6354f023;\n(function(SocketEventType) {\n    SocketEventType[\"Message\"] = \"message\";\n    SocketEventType[\"Disconnected\"] = \"disconnected\";\n    SocketEventType[\"Error\"] = \"error\";\n    SocketEventType[\"Close\"] = \"close\";\n})($e07633d19f7426e9$export$3b5c4a4b6354f023 || ($e07633d19f7426e9$export$3b5c4a4b6354f023 = {}));\nvar $e07633d19f7426e9$export$adb4a1754da6f10d;\n(function(ServerMessageType) {\n    ServerMessageType[\"Heartbeat\"] = \"HEARTBEAT\";\n    ServerMessageType[\"Candidate\"] = \"CANDIDATE\";\n    ServerMessageType[\"Offer\"] = \"OFFER\";\n    ServerMessageType[\"Answer\"] = \"ANSWER\";\n    ServerMessageType[\"Open\"] = \"OPEN\";\n    ServerMessageType[\"Error\"] = \"ERROR\";\n    ServerMessageType[\"IdTaken\"] = \"ID-TAKEN\";\n    ServerMessageType[\"InvalidKey\"] = \"INVALID-KEY\";\n    ServerMessageType[\"Leave\"] = \"LEAVE\";\n    ServerMessageType[\"Expire\"] = \"EXPIRE\";\n})($e07633d19f7426e9$export$adb4a1754da6f10d || ($e07633d19f7426e9$export$adb4a1754da6f10d = {}));\n\n});\n\n\nparcelRegister(\"kRc3N\", function(module, exports) {\n\n$parcel$export(module.exports, \"BaseConnection\", () => $76eedc1a03766751$export$23a2a68283c24d80);\n\nvar $8edWV = parcelRequire(\"8edWV\");\nclass $76eedc1a03766751$export$23a2a68283c24d80 extends (0, $8edWV.EventEmitterWithError) {\n    /**\n\t * Whether the media connection is active (e.g. your call has been answered).\n\t * You can check this if you want to set a maximum wait time for a one-sided call.\n\t */ get open() {\n        return this._open;\n    }\n    constructor(/**\n\t\t * The ID of the peer on the other end of this connection.\n\t\t */ peer, provider, options){\n        super();\n        this.peer = peer;\n        this.provider = provider;\n        this.options = options;\n        this._open = false;\n        this.metadata = options.metadata;\n    }\n}\n\n});\nparcelRegister(\"8edWV\", function(module, exports) {\n\n$parcel$export(module.exports, \"EventEmitterWithError\", () => $428dbabfb6f47b54$export$6a678e589c8a4542);\n\nvar $2b5HH = parcelRequire(\"2b5HH\");\n\nvar $aGTqB = parcelRequire(\"aGTqB\");\nclass $428dbabfb6f47b54$export$6a678e589c8a4542 extends (0, $2b5HH.EventEmitter) {\n    /**\n\t * Emits a typed error message.\n\t *\n\t * @internal\n\t */ emitError(type, err) {\n        (0, $aGTqB.default).error(\"Error:\", err);\n        // @ts-ignore\n        this.emit(\"error\", new $428dbabfb6f47b54$export$98871882f492de82(`${type}`, err));\n    }\n}\nclass $428dbabfb6f47b54$export$98871882f492de82 extends Error {\n    /**\n\t * @internal\n\t */ constructor(type, err){\n        if (typeof err === \"string\") super(err);\n        else {\n            super();\n            Object.assign(this, err);\n        }\n        this.type = type;\n    }\n}\n\n});\nparcelRegister(\"2b5HH\", function(module, exports) {\n\"use strict\";\nvar $1961087dd546fd56$var$has = Object.prototype.hasOwnProperty, $1961087dd546fd56$var$prefix = \"~\";\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */ function $1961087dd546fd56$var$Events() {}\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n    $1961087dd546fd56$var$Events.prototype = Object.create(null);\n    //\n    // This hack is needed because the `__proto__` property is still inherited in\n    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n    //\n    if (!new $1961087dd546fd56$var$Events().__proto__) $1961087dd546fd56$var$prefix = false;\n}\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */ function $1961087dd546fd56$var$EE(fn, context, once) {\n    this.fn = fn;\n    this.context = context;\n    this.once = once || false;\n}\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */ function $1961087dd546fd56$var$addListener(emitter, event, fn, context, once) {\n    if (typeof fn !== \"function\") throw new TypeError(\"The listener must be a function\");\n    var listener = new $1961087dd546fd56$var$EE(fn, context || emitter, once), evt = $1961087dd546fd56$var$prefix ? $1961087dd546fd56$var$prefix + event : event;\n    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n    else emitter._events[evt] = [\n        emitter._events[evt],\n        listener\n    ];\n    return emitter;\n}\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */ function $1961087dd546fd56$var$clearEvent(emitter, evt) {\n    if (--emitter._eventsCount === 0) emitter._events = new $1961087dd546fd56$var$Events();\n    else delete emitter._events[evt];\n}\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */ function $1961087dd546fd56$var$EventEmitter() {\n    this._events = new $1961087dd546fd56$var$Events();\n    this._eventsCount = 0;\n}\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */ $1961087dd546fd56$var$EventEmitter.prototype.eventNames = function eventNames() {\n    var names = [], events, name;\n    if (this._eventsCount === 0) return names;\n    for(name in events = this._events)if ($1961087dd546fd56$var$has.call(events, name)) names.push($1961087dd546fd56$var$prefix ? name.slice(1) : name);\n    if (Object.getOwnPropertySymbols) return names.concat(Object.getOwnPropertySymbols(events));\n    return names;\n};\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */ $1961087dd546fd56$var$EventEmitter.prototype.listeners = function listeners(event) {\n    var evt = $1961087dd546fd56$var$prefix ? $1961087dd546fd56$var$prefix + event : event, handlers = this._events[evt];\n    if (!handlers) return [];\n    if (handlers.fn) return [\n        handlers.fn\n    ];\n    for(var i = 0, l = handlers.length, ee = new Array(l); i < l; i++)ee[i] = handlers[i].fn;\n    return ee;\n};\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */ $1961087dd546fd56$var$EventEmitter.prototype.listenerCount = function listenerCount(event) {\n    var evt = $1961087dd546fd56$var$prefix ? $1961087dd546fd56$var$prefix + event : event, listeners = this._events[evt];\n    if (!listeners) return 0;\n    if (listeners.fn) return 1;\n    return listeners.length;\n};\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */ $1961087dd546fd56$var$EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n    var evt = $1961087dd546fd56$var$prefix ? $1961087dd546fd56$var$prefix + event : event;\n    if (!this._events[evt]) return false;\n    var listeners = this._events[evt], len = arguments.length, args, i;\n    if (listeners.fn) {\n        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n        switch(len){\n            case 1:\n                return listeners.fn.call(listeners.context), true;\n            case 2:\n                return listeners.fn.call(listeners.context, a1), true;\n            case 3:\n                return listeners.fn.call(listeners.context, a1, a2), true;\n            case 4:\n                return listeners.fn.call(listeners.context, a1, a2, a3), true;\n            case 5:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n            case 6:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n        }\n        for(i = 1, args = new Array(len - 1); i < len; i++)args[i - 1] = arguments[i];\n        listeners.fn.apply(listeners.context, args);\n    } else {\n        var length = listeners.length, j;\n        for(i = 0; i < length; i++){\n            if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n            switch(len){\n                case 1:\n                    listeners[i].fn.call(listeners[i].context);\n                    break;\n                case 2:\n                    listeners[i].fn.call(listeners[i].context, a1);\n                    break;\n                case 3:\n                    listeners[i].fn.call(listeners[i].context, a1, a2);\n                    break;\n                case 4:\n                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n                    break;\n                default:\n                    if (!args) for(j = 1, args = new Array(len - 1); j < len; j++)args[j - 1] = arguments[j];\n                    listeners[i].fn.apply(listeners[i].context, args);\n            }\n        }\n    }\n    return true;\n};\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */ $1961087dd546fd56$var$EventEmitter.prototype.on = function on(event, fn, context) {\n    return $1961087dd546fd56$var$addListener(this, event, fn, context, false);\n};\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */ $1961087dd546fd56$var$EventEmitter.prototype.once = function once(event, fn, context) {\n    return $1961087dd546fd56$var$addListener(this, event, fn, context, true);\n};\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */ $1961087dd546fd56$var$EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n    var evt = $1961087dd546fd56$var$prefix ? $1961087dd546fd56$var$prefix + event : event;\n    if (!this._events[evt]) return this;\n    if (!fn) {\n        $1961087dd546fd56$var$clearEvent(this, evt);\n        return this;\n    }\n    var listeners = this._events[evt];\n    if (listeners.fn) {\n        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) $1961087dd546fd56$var$clearEvent(this, evt);\n    } else {\n        for(var i = 0, events = [], length = listeners.length; i < length; i++)if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) events.push(listeners[i]);\n        //\n        // Reset the array, or remove it completely if we have no more listeners.\n        //\n        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n        else $1961087dd546fd56$var$clearEvent(this, evt);\n    }\n    return this;\n};\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */ $1961087dd546fd56$var$EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n    var evt;\n    if (event) {\n        evt = $1961087dd546fd56$var$prefix ? $1961087dd546fd56$var$prefix + event : event;\n        if (this._events[evt]) $1961087dd546fd56$var$clearEvent(this, evt);\n    } else {\n        this._events = new $1961087dd546fd56$var$Events();\n        this._eventsCount = 0;\n    }\n    return this;\n};\n//\n// Alias methods names because people roll like that.\n//\n$1961087dd546fd56$var$EventEmitter.prototype.off = $1961087dd546fd56$var$EventEmitter.prototype.removeListener;\n$1961087dd546fd56$var$EventEmitter.prototype.addListener = $1961087dd546fd56$var$EventEmitter.prototype.on;\n//\n// Expose the prefix.\n//\n$1961087dd546fd56$var$EventEmitter.prefixed = $1961087dd546fd56$var$prefix;\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\n$1961087dd546fd56$var$EventEmitter.EventEmitter = $1961087dd546fd56$var$EventEmitter;\nmodule.exports = $1961087dd546fd56$var$EventEmitter;\n\n});\n\n\n\nparcelRegister(\"9Ek5E\", function(module, exports) {\n\n$parcel$export(module.exports, \"randomToken\", () => $eb916fa843978df9$export$4e61f672936bec77);\nconst $eb916fa843978df9$export$4e61f672936bec77 = ()=>Math.random().toString(36).slice(2);\n\n});\n\n\n\n\nvar $5L6jO = parcelRequire(\"5L6jO\");\nvar $98f674c4cc22e340$require$Buffer = $5L6jO.Buffer;\nlet $98f674c4cc22e340$var$decoder;\ntry {\n    $98f674c4cc22e340$var$decoder = new TextDecoder();\n} catch (error) {}\nlet $98f674c4cc22e340$var$src;\nlet $98f674c4cc22e340$var$srcEnd;\nlet $98f674c4cc22e340$var$position = 0;\nlet $98f674c4cc22e340$var$alreadySet;\nconst $98f674c4cc22e340$var$EMPTY_ARRAY = [];\nconst $98f674c4cc22e340$var$LEGACY_RECORD_INLINE_ID = 105;\nconst $98f674c4cc22e340$var$RECORD_DEFINITIONS_ID = 0xdffe;\nconst $98f674c4cc22e340$var$RECORD_INLINE_ID = 0xdfff // temporary first-come first-serve tag // proposed tag: 0x7265 // 're'\n;\nconst $98f674c4cc22e340$var$BUNDLED_STRINGS_ID = 0xdff9;\nconst $98f674c4cc22e340$var$PACKED_TABLE_TAG_ID = 51;\nconst $98f674c4cc22e340$var$PACKED_REFERENCE_TAG_ID = 6;\nconst $98f674c4cc22e340$var$STOP_CODE = {};\nlet $98f674c4cc22e340$var$strings = $98f674c4cc22e340$var$EMPTY_ARRAY;\nlet $98f674c4cc22e340$var$stringPosition = 0;\nlet $98f674c4cc22e340$var$currentDecoder = {};\nlet $98f674c4cc22e340$var$currentStructures;\nlet $98f674c4cc22e340$var$srcString;\nlet $98f674c4cc22e340$var$srcStringStart = 0;\nlet $98f674c4cc22e340$var$srcStringEnd = 0;\nlet $98f674c4cc22e340$var$bundledStrings;\nlet $98f674c4cc22e340$var$referenceMap;\nlet $98f674c4cc22e340$var$currentExtensions = [];\nlet $98f674c4cc22e340$var$currentExtensionRanges = [];\nlet $98f674c4cc22e340$var$packedValues;\nlet $98f674c4cc22e340$var$dataView;\nlet $98f674c4cc22e340$var$restoreMapsAsObject;\nlet $98f674c4cc22e340$var$defaultOptions = {\n    useRecords: false,\n    mapsAsObjects: true\n};\nlet $98f674c4cc22e340$var$sequentialMode = false;\nlet $98f674c4cc22e340$var$inlineObjectReadThreshold = 2;\nvar $98f674c4cc22e340$var$BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n;\n// no-eval build\ntry {\n    new Function(\"\");\n} catch (error) {\n    // if eval variants are not supported, do not create inline object readers ever\n    $98f674c4cc22e340$var$inlineObjectReadThreshold = Infinity;\n}\nclass $98f674c4cc22e340$export$f9de6ca0bc043724 {\n    constructor(options){\n        if (options) {\n            if ((options.keyMap || options._keyMap) && !options.useRecords) {\n                options.useRecords = false;\n                options.mapsAsObjects = true;\n            }\n            if (options.useRecords === false && options.mapsAsObjects === undefined) options.mapsAsObjects = true;\n            if (options.getStructures) options.getShared = options.getStructures;\n            if (options.getShared && !options.structures) (options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n            ;\n            if (options.keyMap) {\n                this.mapKey = new Map();\n                for (let [k, v] of Object.entries(options.keyMap))this.mapKey.set(v, k);\n            }\n        }\n        Object.assign(this, options);\n    }\n    /*\n\tdecodeKey(key) {\n\t\treturn this.keyMap\n\t\t\t? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key\n\t\t\t: key\n\t}\n\t*/ decodeKey(key) {\n        return this.keyMap ? this.mapKey.get(key) || key : key;\n    }\n    encodeKey(key) {\n        return this.keyMap && this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key;\n    }\n    encodeKeys(rec) {\n        if (!this._keyMap) return rec;\n        let map = new Map();\n        for (let [k, v] of Object.entries(rec))map.set(this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k, v);\n        return map;\n    }\n    decodeKeys(map) {\n        if (!this._keyMap || map.constructor.name != \"Map\") return map;\n        if (!this._mapKey) {\n            this._mapKey = new Map();\n            for (let [k, v] of Object.entries(this._keyMap))this._mapKey.set(v, k);\n        }\n        let res = {};\n        //map.forEach((v,k) => res[Object.keys(this._keyMap)[Object.values(this._keyMap).indexOf(k)] || k] = v)\n        map.forEach((v, k)=>res[$98f674c4cc22e340$var$safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] = v);\n        return res;\n    }\n    mapDecode(source, end) {\n        let res = this.decode(source);\n        if (this._keyMap) //Experiemntal support for Optimised KeyMap  decoding \n        switch(res.constructor.name){\n            case \"Array\":\n                return res.map((r)=>this.decodeKeys(r));\n        }\n        return res;\n    }\n    decode(source, end) {\n        if ($98f674c4cc22e340$var$src) // re-entrant execution, save the state and restore it after we do this decode\n        return $98f674c4cc22e340$var$saveState(()=>{\n            $98f674c4cc22e340$export$e6f020404d5b6c15();\n            return this ? this.decode(source, end) : $98f674c4cc22e340$export$f9de6ca0bc043724.prototype.decode.call($98f674c4cc22e340$var$defaultOptions, source, end);\n        });\n        $98f674c4cc22e340$var$srcEnd = end > -1 ? end : source.length;\n        $98f674c4cc22e340$var$position = 0;\n        $98f674c4cc22e340$var$stringPosition = 0;\n        $98f674c4cc22e340$var$srcStringEnd = 0;\n        $98f674c4cc22e340$var$srcString = null;\n        $98f674c4cc22e340$var$strings = $98f674c4cc22e340$var$EMPTY_ARRAY;\n        $98f674c4cc22e340$var$bundledStrings = null;\n        $98f674c4cc22e340$var$src = source;\n        // this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n        // technique for getting data from a database where it can be copied into an existing buffer instead of creating\n        // new ones\n        try {\n            $98f674c4cc22e340$var$dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));\n        } catch (error) {\n            // if it doesn't have a buffer, maybe it is the wrong type of object\n            $98f674c4cc22e340$var$src = null;\n            if (source instanceof Uint8Array) throw error;\n            throw new Error(\"Source must be a Uint8Array or Buffer but was a \" + (source && typeof source == \"object\" ? source.constructor.name : typeof source));\n        }\n        if (this instanceof $98f674c4cc22e340$export$f9de6ca0bc043724) {\n            $98f674c4cc22e340$var$currentDecoder = this;\n            $98f674c4cc22e340$var$packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);\n            if (this.structures) {\n                $98f674c4cc22e340$var$currentStructures = this.structures;\n                return $98f674c4cc22e340$export$8cb90b5f58dd32e2();\n            } else if (!$98f674c4cc22e340$var$currentStructures || $98f674c4cc22e340$var$currentStructures.length > 0) $98f674c4cc22e340$var$currentStructures = [];\n        } else {\n            $98f674c4cc22e340$var$currentDecoder = $98f674c4cc22e340$var$defaultOptions;\n            if (!$98f674c4cc22e340$var$currentStructures || $98f674c4cc22e340$var$currentStructures.length > 0) $98f674c4cc22e340$var$currentStructures = [];\n            $98f674c4cc22e340$var$packedValues = null;\n        }\n        return $98f674c4cc22e340$export$8cb90b5f58dd32e2();\n    }\n    decodeMultiple(source, forEach) {\n        let values, lastPosition = 0;\n        try {\n            let size = source.length;\n            $98f674c4cc22e340$var$sequentialMode = true;\n            let value = this ? this.decode(source, size) : $98f674c4cc22e340$var$defaultDecoder.decode(source, size);\n            if (forEach) {\n                if (forEach(value) === false) return;\n                while($98f674c4cc22e340$var$position < size){\n                    lastPosition = $98f674c4cc22e340$var$position;\n                    if (forEach($98f674c4cc22e340$export$8cb90b5f58dd32e2()) === false) return;\n                }\n            } else {\n                values = [\n                    value\n                ];\n                while($98f674c4cc22e340$var$position < size){\n                    lastPosition = $98f674c4cc22e340$var$position;\n                    values.push($98f674c4cc22e340$export$8cb90b5f58dd32e2());\n                }\n                return values;\n            }\n        } catch (error) {\n            error.lastPosition = lastPosition;\n            error.values = values;\n            throw error;\n        } finally{\n            $98f674c4cc22e340$var$sequentialMode = false;\n            $98f674c4cc22e340$export$e6f020404d5b6c15();\n        }\n    }\n}\nfunction $98f674c4cc22e340$export$1690e12b840569b9() {\n    return $98f674c4cc22e340$var$position;\n}\nfunction $98f674c4cc22e340$export$8cb90b5f58dd32e2() {\n    try {\n        let result = $98f674c4cc22e340$export$aafa59e2e03f2942();\n        if ($98f674c4cc22e340$var$bundledStrings) {\n            if ($98f674c4cc22e340$var$position >= $98f674c4cc22e340$var$bundledStrings.postBundlePosition) {\n                let error = new Error(\"Unexpected bundle position\");\n                error.incomplete = true;\n                throw error;\n            }\n            // bundled strings to skip past\n            $98f674c4cc22e340$var$position = $98f674c4cc22e340$var$bundledStrings.postBundlePosition;\n            $98f674c4cc22e340$var$bundledStrings = null;\n        }\n        if ($98f674c4cc22e340$var$position == $98f674c4cc22e340$var$srcEnd) {\n            // finished reading this source, cleanup references\n            $98f674c4cc22e340$var$currentStructures = null;\n            $98f674c4cc22e340$var$src = null;\n            if ($98f674c4cc22e340$var$referenceMap) $98f674c4cc22e340$var$referenceMap = null;\n        } else if ($98f674c4cc22e340$var$position > $98f674c4cc22e340$var$srcEnd) {\n            // over read\n            let error = new Error(\"Unexpected end of CBOR data\");\n            error.incomplete = true;\n            throw error;\n        } else if (!$98f674c4cc22e340$var$sequentialMode) throw new Error(\"Data read, but end of buffer not reached\");\n        // else more to read, but we are reading sequentially, so don't clear source yet\n        return result;\n    } catch (error) {\n        $98f674c4cc22e340$export$e6f020404d5b6c15();\n        if (error instanceof RangeError || error.message.startsWith(\"Unexpected end of buffer\")) error.incomplete = true;\n        throw error;\n    }\n}\nfunction $98f674c4cc22e340$export$aafa59e2e03f2942() {\n    let token = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n    let majorType = token >> 5;\n    token = token & 0x1f;\n    if (token > 0x17) switch(token){\n        case 0x18:\n            token = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n            break;\n        case 0x19:\n            if (majorType == 7) return $98f674c4cc22e340$var$getFloat16();\n            token = $98f674c4cc22e340$var$dataView.getUint16($98f674c4cc22e340$var$position);\n            $98f674c4cc22e340$var$position += 2;\n            break;\n        case 0x1a:\n            if (majorType == 7) {\n                let value = $98f674c4cc22e340$var$dataView.getFloat32($98f674c4cc22e340$var$position);\n                if ($98f674c4cc22e340$var$currentDecoder.useFloat32 > 2) {\n                    // this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n                    let multiplier = $98f674c4cc22e340$export$c652a5bbb6be7a36[($98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position] & 0x7f) << 1 | $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position + 1] >> 7];\n                    $98f674c4cc22e340$var$position += 4;\n                    return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;\n                }\n                $98f674c4cc22e340$var$position += 4;\n                return value;\n            }\n            token = $98f674c4cc22e340$var$dataView.getUint32($98f674c4cc22e340$var$position);\n            $98f674c4cc22e340$var$position += 4;\n            break;\n        case 0x1b:\n            if (majorType == 7) {\n                let value = $98f674c4cc22e340$var$dataView.getFloat64($98f674c4cc22e340$var$position);\n                $98f674c4cc22e340$var$position += 8;\n                return value;\n            }\n            if (majorType > 1) {\n                if ($98f674c4cc22e340$var$dataView.getUint32($98f674c4cc22e340$var$position) > 0) throw new Error(\"JavaScript does not support arrays, maps, or strings with length over 4294967295\");\n                token = $98f674c4cc22e340$var$dataView.getUint32($98f674c4cc22e340$var$position + 4);\n            } else if ($98f674c4cc22e340$var$currentDecoder.int64AsNumber) {\n                token = $98f674c4cc22e340$var$dataView.getUint32($98f674c4cc22e340$var$position) * 0x100000000;\n                token += $98f674c4cc22e340$var$dataView.getUint32($98f674c4cc22e340$var$position + 4);\n            } else token = $98f674c4cc22e340$var$dataView.getBigUint64($98f674c4cc22e340$var$position);\n            $98f674c4cc22e340$var$position += 8;\n            break;\n        case 0x1f:\n            // indefinite length\n            switch(majorType){\n                case 2:\n                case 3:\n                    throw new Error(\"Indefinite length not supported for byte or text strings\");\n                case 4:\n                    let array = [];\n                    let value, i = 0;\n                    while((value = $98f674c4cc22e340$export$aafa59e2e03f2942()) != $98f674c4cc22e340$var$STOP_CODE)array[i++] = value;\n                    return majorType == 4 ? array : majorType == 3 ? array.join(\"\") : $98f674c4cc22e340$require$Buffer.concat(array);\n                case 5:\n                    let key;\n                    if ($98f674c4cc22e340$var$currentDecoder.mapsAsObjects) {\n                        let object = {};\n                        if ($98f674c4cc22e340$var$currentDecoder.keyMap) while((key = $98f674c4cc22e340$export$aafa59e2e03f2942()) != $98f674c4cc22e340$var$STOP_CODE)object[$98f674c4cc22e340$var$safeKey($98f674c4cc22e340$var$currentDecoder.decodeKey(key))] = $98f674c4cc22e340$export$aafa59e2e03f2942();\n                        else while((key = $98f674c4cc22e340$export$aafa59e2e03f2942()) != $98f674c4cc22e340$var$STOP_CODE)object[$98f674c4cc22e340$var$safeKey(key)] = $98f674c4cc22e340$export$aafa59e2e03f2942();\n                        return object;\n                    } else {\n                        if ($98f674c4cc22e340$var$restoreMapsAsObject) {\n                            $98f674c4cc22e340$var$currentDecoder.mapsAsObjects = true;\n                            $98f674c4cc22e340$var$restoreMapsAsObject = false;\n                        }\n                        let map = new Map();\n                        if ($98f674c4cc22e340$var$currentDecoder.keyMap) while((key = $98f674c4cc22e340$export$aafa59e2e03f2942()) != $98f674c4cc22e340$var$STOP_CODE)map.set($98f674c4cc22e340$var$currentDecoder.decodeKey(key), $98f674c4cc22e340$export$aafa59e2e03f2942());\n                        else while((key = $98f674c4cc22e340$export$aafa59e2e03f2942()) != $98f674c4cc22e340$var$STOP_CODE)map.set(key, $98f674c4cc22e340$export$aafa59e2e03f2942());\n                        return map;\n                    }\n                case 7:\n                    return $98f674c4cc22e340$var$STOP_CODE;\n                default:\n                    throw new Error(\"Invalid major type for indefinite length \" + majorType);\n            }\n        default:\n            throw new Error(\"Unknown token \" + token);\n    }\n    switch(majorType){\n        case 0:\n            return token;\n        case 1:\n            return ~token;\n        case 2:\n            return $98f674c4cc22e340$var$readBin(token);\n        case 3:\n            if ($98f674c4cc22e340$var$srcStringEnd >= $98f674c4cc22e340$var$position) return $98f674c4cc22e340$var$srcString.slice($98f674c4cc22e340$var$position - $98f674c4cc22e340$var$srcStringStart, ($98f674c4cc22e340$var$position += token) - $98f674c4cc22e340$var$srcStringStart);\n            if ($98f674c4cc22e340$var$srcStringEnd == 0 && $98f674c4cc22e340$var$srcEnd < 140 && token < 32) {\n                // for small blocks, avoiding the overhead of the extract call is helpful\n                let string = token < 16 ? $98f674c4cc22e340$var$shortStringInJS(token) : $98f674c4cc22e340$var$longStringInJS(token);\n                if (string != null) return string;\n            }\n            return $98f674c4cc22e340$var$readFixedString(token);\n        case 4:\n            let array1 = new Array(token);\n            //if (currentDecoder.keyMap) for (let i = 0; i < token; i++) array[i] = currentDecoder.decodeKey(read())\t\n            //else \n            for(let i = 0; i < token; i++)array1[i] = $98f674c4cc22e340$export$aafa59e2e03f2942();\n            return array1;\n        case 5:\n            if ($98f674c4cc22e340$var$currentDecoder.mapsAsObjects) {\n                let object = {};\n                if ($98f674c4cc22e340$var$currentDecoder.keyMap) for(let i = 0; i < token; i++)object[$98f674c4cc22e340$var$safeKey($98f674c4cc22e340$var$currentDecoder.decodeKey($98f674c4cc22e340$export$aafa59e2e03f2942()))] = $98f674c4cc22e340$export$aafa59e2e03f2942();\n                else for(let i = 0; i < token; i++)object[$98f674c4cc22e340$var$safeKey($98f674c4cc22e340$export$aafa59e2e03f2942())] = $98f674c4cc22e340$export$aafa59e2e03f2942();\n                return object;\n            } else {\n                if ($98f674c4cc22e340$var$restoreMapsAsObject) {\n                    $98f674c4cc22e340$var$currentDecoder.mapsAsObjects = true;\n                    $98f674c4cc22e340$var$restoreMapsAsObject = false;\n                }\n                let map = new Map();\n                if ($98f674c4cc22e340$var$currentDecoder.keyMap) for(let i = 0; i < token; i++)map.set($98f674c4cc22e340$var$currentDecoder.decodeKey($98f674c4cc22e340$export$aafa59e2e03f2942()), $98f674c4cc22e340$export$aafa59e2e03f2942());\n                else for(let i = 0; i < token; i++)map.set($98f674c4cc22e340$export$aafa59e2e03f2942(), $98f674c4cc22e340$export$aafa59e2e03f2942());\n                return map;\n            }\n        case 6:\n            if (token >= $98f674c4cc22e340$var$BUNDLED_STRINGS_ID) {\n                let structure = $98f674c4cc22e340$var$currentStructures[token & 0x1fff] // check record structures first\n                ;\n                // At some point we may provide an option for dynamic tag assignment with a range like token >= 8 && (token < 16 || (token > 0x80 && token < 0xc0) || (token > 0x130 && token < 0x4000))\n                if (structure) {\n                    if (!structure.read) structure.read = $98f674c4cc22e340$var$createStructureReader(structure);\n                    return structure.read();\n                }\n                if (token < 0x10000) {\n                    if (token == $98f674c4cc22e340$var$RECORD_INLINE_ID) {\n                        // currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n                        let length = $98f674c4cc22e340$var$readJustLength();\n                        let id = $98f674c4cc22e340$export$aafa59e2e03f2942();\n                        let structure = $98f674c4cc22e340$export$aafa59e2e03f2942();\n                        $98f674c4cc22e340$var$recordDefinition(id, structure);\n                        let object = {};\n                        if ($98f674c4cc22e340$var$currentDecoder.keyMap) for(let i = 2; i < length; i++){\n                            let key = $98f674c4cc22e340$var$currentDecoder.decodeKey(structure[i - 2]);\n                            object[$98f674c4cc22e340$var$safeKey(key)] = $98f674c4cc22e340$export$aafa59e2e03f2942();\n                        }\n                        else for(let i = 2; i < length; i++){\n                            let key = structure[i - 2];\n                            object[$98f674c4cc22e340$var$safeKey(key)] = $98f674c4cc22e340$export$aafa59e2e03f2942();\n                        }\n                        return object;\n                    } else if (token == $98f674c4cc22e340$var$RECORD_DEFINITIONS_ID) {\n                        let length = $98f674c4cc22e340$var$readJustLength();\n                        let id = $98f674c4cc22e340$export$aafa59e2e03f2942();\n                        for(let i = 2; i < length; i++)$98f674c4cc22e340$var$recordDefinition(id++, $98f674c4cc22e340$export$aafa59e2e03f2942());\n                        return $98f674c4cc22e340$export$aafa59e2e03f2942();\n                    } else if (token == $98f674c4cc22e340$var$BUNDLED_STRINGS_ID) return $98f674c4cc22e340$var$readBundleExt();\n                    if ($98f674c4cc22e340$var$currentDecoder.getShared) {\n                        $98f674c4cc22e340$var$loadShared();\n                        structure = $98f674c4cc22e340$var$currentStructures[token & 0x1fff];\n                        if (structure) {\n                            if (!structure.read) structure.read = $98f674c4cc22e340$var$createStructureReader(structure);\n                            return structure.read();\n                        }\n                    }\n                }\n            }\n            let extension = $98f674c4cc22e340$var$currentExtensions[token];\n            if (extension) {\n                if (extension.handlesRead) return extension($98f674c4cc22e340$export$aafa59e2e03f2942);\n                else return extension($98f674c4cc22e340$export$aafa59e2e03f2942());\n            } else {\n                let input = $98f674c4cc22e340$export$aafa59e2e03f2942();\n                for(let i = 0; i < $98f674c4cc22e340$var$currentExtensionRanges.length; i++){\n                    let value = $98f674c4cc22e340$var$currentExtensionRanges[i](token, input);\n                    if (value !== undefined) return value;\n                }\n                return new $98f674c4cc22e340$export$3288d34c523a1192(input, token);\n            }\n        case 7:\n            switch(token){\n                case 0x14:\n                    return false;\n                case 0x15:\n                    return true;\n                case 0x16:\n                    return null;\n                case 0x17:\n                    return; // undefined\n                case 0x1f:\n                default:\n                    let packedValue = ($98f674c4cc22e340$var$packedValues || $98f674c4cc22e340$var$getPackedValues())[token];\n                    if (packedValue !== undefined) return packedValue;\n                    throw new Error(\"Unknown token \" + token);\n            }\n        default:\n            if (isNaN(token)) {\n                let error = new Error(\"Unexpected end of CBOR data\");\n                error.incomplete = true;\n                throw error;\n            }\n            throw new Error(\"Unknown CBOR token \" + token);\n    }\n}\nconst $98f674c4cc22e340$var$validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/;\nfunction $98f674c4cc22e340$var$createStructureReader(structure) {\n    function readObject() {\n        // get the array size from the header\n        let length = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n        //let majorType = token >> 5\n        length = length & 0x1f;\n        if (length > 0x17) switch(length){\n            case 0x18:\n                length = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n                break;\n            case 0x19:\n                length = $98f674c4cc22e340$var$dataView.getUint16($98f674c4cc22e340$var$position);\n                $98f674c4cc22e340$var$position += 2;\n                break;\n            case 0x1a:\n                length = $98f674c4cc22e340$var$dataView.getUint32($98f674c4cc22e340$var$position);\n                $98f674c4cc22e340$var$position += 4;\n                break;\n            default:\n                throw new Error(\"Expected array header, but got \" + $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position - 1]);\n        }\n        // This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n        let compiledReader = this.compiledReader // first look to see if we have the fast compiled function\n        ;\n        while(compiledReader){\n            // we have a fast compiled object literal reader\n            if (compiledReader.propertyCount === length) return compiledReader($98f674c4cc22e340$export$aafa59e2e03f2942) // with the right length, so we use it\n            ;\n            compiledReader = compiledReader.next // see if there is another reader with the right length\n            ;\n        }\n        if (this.slowReads++ >= $98f674c4cc22e340$var$inlineObjectReadThreshold) {\n            let array = this.length == length ? this : this.slice(0, length);\n            compiledReader = $98f674c4cc22e340$var$currentDecoder.keyMap ? new Function(\"r\", \"return {\" + array.map((k)=>$98f674c4cc22e340$var$currentDecoder.decodeKey(k)).map((k)=>$98f674c4cc22e340$var$validName.test(k) ? $98f674c4cc22e340$var$safeKey(k) + \":r()\" : \"[\" + JSON.stringify(k) + \"]:r()\").join(\",\") + \"}\") : new Function(\"r\", \"return {\" + array.map((key)=>$98f674c4cc22e340$var$validName.test(key) ? $98f674c4cc22e340$var$safeKey(key) + \":r()\" : \"[\" + JSON.stringify(key) + \"]:r()\").join(\",\") + \"}\");\n            if (this.compiledReader) compiledReader.next = this.compiledReader // if there is an existing one, we store multiple readers as a linked list because it is usually pretty rare to have multiple readers (of different length) for the same structure\n            ;\n            compiledReader.propertyCount = length;\n            this.compiledReader = compiledReader;\n            return compiledReader($98f674c4cc22e340$export$aafa59e2e03f2942);\n        }\n        let object = {};\n        if ($98f674c4cc22e340$var$currentDecoder.keyMap) for(let i = 0; i < length; i++)object[$98f674c4cc22e340$var$safeKey($98f674c4cc22e340$var$currentDecoder.decodeKey(this[i]))] = $98f674c4cc22e340$export$aafa59e2e03f2942();\n        else for(let i = 0; i < length; i++)object[$98f674c4cc22e340$var$safeKey(this[i])] = $98f674c4cc22e340$export$aafa59e2e03f2942();\n        return object;\n    }\n    structure.slowReads = 0;\n    return readObject;\n}\nfunction $98f674c4cc22e340$var$safeKey(key) {\n    return key === \"__proto__\" ? \"__proto_\" : key;\n}\nlet $98f674c4cc22e340$var$readFixedString = $98f674c4cc22e340$var$readStringJS;\nlet $98f674c4cc22e340$var$readString8 = $98f674c4cc22e340$var$readStringJS;\nlet $98f674c4cc22e340$var$readString16 = $98f674c4cc22e340$var$readStringJS;\nlet $98f674c4cc22e340$var$readString32 = $98f674c4cc22e340$var$readStringJS;\nlet $98f674c4cc22e340$export$ae7c2166c4fa454a = false;\nfunction $98f674c4cc22e340$export$b9cf06aee99126ca(extractStrings) {\n    $98f674c4cc22e340$export$ae7c2166c4fa454a = true;\n    $98f674c4cc22e340$var$readFixedString = readString(1);\n    $98f674c4cc22e340$var$readString8 = readString(2);\n    $98f674c4cc22e340$var$readString16 = readString(3);\n    $98f674c4cc22e340$var$readString32 = readString(5);\n    function readString(headerLength) {\n        return function readString(length) {\n            let string = $98f674c4cc22e340$var$strings[$98f674c4cc22e340$var$stringPosition++];\n            if (string == null) {\n                if ($98f674c4cc22e340$var$bundledStrings) return $98f674c4cc22e340$var$readStringJS(length);\n                let extraction = extractStrings($98f674c4cc22e340$var$position, $98f674c4cc22e340$var$srcEnd, length, $98f674c4cc22e340$var$src);\n                if (typeof extraction == \"string\") {\n                    string = extraction;\n                    $98f674c4cc22e340$var$strings = $98f674c4cc22e340$var$EMPTY_ARRAY;\n                } else {\n                    $98f674c4cc22e340$var$strings = extraction;\n                    $98f674c4cc22e340$var$stringPosition = 1;\n                    $98f674c4cc22e340$var$srcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n                    ;\n                    string = $98f674c4cc22e340$var$strings[0];\n                    if (string === undefined) throw new Error(\"Unexpected end of buffer\");\n                }\n            }\n            let srcStringLength = string.length;\n            if (srcStringLength <= length) {\n                $98f674c4cc22e340$var$position += length;\n                return string;\n            }\n            $98f674c4cc22e340$var$srcString = string;\n            $98f674c4cc22e340$var$srcStringStart = $98f674c4cc22e340$var$position;\n            $98f674c4cc22e340$var$srcStringEnd = $98f674c4cc22e340$var$position + srcStringLength;\n            $98f674c4cc22e340$var$position += length;\n            return string.slice(0, length) // we know we just want the beginning\n            ;\n        };\n    }\n}\nfunction $98f674c4cc22e340$var$readStringJS(length) {\n    let result;\n    if (length < 16) {\n        if (result = $98f674c4cc22e340$var$shortStringInJS(length)) return result;\n    }\n    if (length > 64 && $98f674c4cc22e340$var$decoder) return $98f674c4cc22e340$var$decoder.decode($98f674c4cc22e340$var$src.subarray($98f674c4cc22e340$var$position, $98f674c4cc22e340$var$position += length));\n    const end = $98f674c4cc22e340$var$position + length;\n    const units = [];\n    result = \"\";\n    while($98f674c4cc22e340$var$position < end){\n        const byte1 = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n        if ((byte1 & 0x80) === 0) // 1 byte\n        units.push(byte1);\n        else if ((byte1 & 0xe0) === 0xc0) {\n            // 2 bytes\n            const byte2 = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++] & 0x3f;\n            units.push((byte1 & 0x1f) << 6 | byte2);\n        } else if ((byte1 & 0xf0) === 0xe0) {\n            // 3 bytes\n            const byte2 = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++] & 0x3f;\n            const byte3 = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++] & 0x3f;\n            units.push((byte1 & 0x1f) << 12 | byte2 << 6 | byte3);\n        } else if ((byte1 & 0xf8) === 0xf0) {\n            // 4 bytes\n            const byte2 = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++] & 0x3f;\n            const byte3 = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++] & 0x3f;\n            const byte4 = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++] & 0x3f;\n            let unit = (byte1 & 0x07) << 0x12 | byte2 << 0x0c | byte3 << 0x06 | byte4;\n            if (unit > 0xffff) {\n                unit -= 0x10000;\n                units.push(unit >>> 10 & 0x3ff | 0xd800);\n                unit = 0xdc00 | unit & 0x3ff;\n            }\n            units.push(unit);\n        } else units.push(byte1);\n        if (units.length >= 0x1000) {\n            result += $98f674c4cc22e340$var$fromCharCode.apply(String, units);\n            units.length = 0;\n        }\n    }\n    if (units.length > 0) result += $98f674c4cc22e340$var$fromCharCode.apply(String, units);\n    return result;\n}\nlet $98f674c4cc22e340$var$fromCharCode = String.fromCharCode;\nfunction $98f674c4cc22e340$var$longStringInJS(length) {\n    let start = $98f674c4cc22e340$var$position;\n    let bytes = new Array(length);\n    for(let i = 0; i < length; i++){\n        const byte = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n        if ((byte & 0x80) > 0) {\n            $98f674c4cc22e340$var$position = start;\n            return;\n        }\n        bytes[i] = byte;\n    }\n    return $98f674c4cc22e340$var$fromCharCode.apply(String, bytes);\n}\nfunction $98f674c4cc22e340$var$shortStringInJS(length) {\n    if (length < 4) {\n        if (length < 2) {\n            if (length === 0) return \"\";\n            else {\n                let a = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n                if ((a & 0x80) > 1) {\n                    $98f674c4cc22e340$var$position -= 1;\n                    return;\n                }\n                return $98f674c4cc22e340$var$fromCharCode(a);\n            }\n        } else {\n            let a = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n            let b = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n            if ((a & 0x80) > 0 || (b & 0x80) > 0) {\n                $98f674c4cc22e340$var$position -= 2;\n                return;\n            }\n            if (length < 3) return $98f674c4cc22e340$var$fromCharCode(a, b);\n            let c = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n            if ((c & 0x80) > 0) {\n                $98f674c4cc22e340$var$position -= 3;\n                return;\n            }\n            return $98f674c4cc22e340$var$fromCharCode(a, b, c);\n        }\n    } else {\n        let a = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n        let b = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n        let c = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n        let d = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n        if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n            $98f674c4cc22e340$var$position -= 4;\n            return;\n        }\n        if (length < 6) {\n            if (length === 4) return $98f674c4cc22e340$var$fromCharCode(a, b, c, d);\n            else {\n                let e = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n                if ((e & 0x80) > 0) {\n                    $98f674c4cc22e340$var$position -= 5;\n                    return;\n                }\n                return $98f674c4cc22e340$var$fromCharCode(a, b, c, d, e);\n            }\n        } else if (length < 8) {\n            let e = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n            let f = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n            if ((e & 0x80) > 0 || (f & 0x80) > 0) {\n                $98f674c4cc22e340$var$position -= 6;\n                return;\n            }\n            if (length < 7) return $98f674c4cc22e340$var$fromCharCode(a, b, c, d, e, f);\n            let g = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n            if ((g & 0x80) > 0) {\n                $98f674c4cc22e340$var$position -= 7;\n                return;\n            }\n            return $98f674c4cc22e340$var$fromCharCode(a, b, c, d, e, f, g);\n        } else {\n            let e = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n            let f = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n            let g = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n            let h = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n            if ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n                $98f674c4cc22e340$var$position -= 8;\n                return;\n            }\n            if (length < 10) {\n                if (length === 8) return $98f674c4cc22e340$var$fromCharCode(a, b, c, d, e, f, g, h);\n                else {\n                    let i = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n                    if ((i & 0x80) > 0) {\n                        $98f674c4cc22e340$var$position -= 9;\n                        return;\n                    }\n                    return $98f674c4cc22e340$var$fromCharCode(a, b, c, d, e, f, g, h, i);\n                }\n            } else if (length < 12) {\n                let i = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n                let j = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n                if ((i & 0x80) > 0 || (j & 0x80) > 0) {\n                    $98f674c4cc22e340$var$position -= 10;\n                    return;\n                }\n                if (length < 11) return $98f674c4cc22e340$var$fromCharCode(a, b, c, d, e, f, g, h, i, j);\n                let k = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n                if ((k & 0x80) > 0) {\n                    $98f674c4cc22e340$var$position -= 11;\n                    return;\n                }\n                return $98f674c4cc22e340$var$fromCharCode(a, b, c, d, e, f, g, h, i, j, k);\n            } else {\n                let i = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n                let j = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n                let k = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n                let l = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n                if ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n                    $98f674c4cc22e340$var$position -= 12;\n                    return;\n                }\n                if (length < 14) {\n                    if (length === 12) return $98f674c4cc22e340$var$fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);\n                    else {\n                        let m = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n                        if ((m & 0x80) > 0) {\n                            $98f674c4cc22e340$var$position -= 13;\n                            return;\n                        }\n                        return $98f674c4cc22e340$var$fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);\n                    }\n                } else {\n                    let m = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n                    let n = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n                    if ((m & 0x80) > 0 || (n & 0x80) > 0) {\n                        $98f674c4cc22e340$var$position -= 14;\n                        return;\n                    }\n                    if (length < 15) return $98f674c4cc22e340$var$fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);\n                    let o = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n                    if ((o & 0x80) > 0) {\n                        $98f674c4cc22e340$var$position -= 15;\n                        return;\n                    }\n                    return $98f674c4cc22e340$var$fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);\n                }\n            }\n        }\n    }\n}\nfunction $98f674c4cc22e340$var$readBin(length) {\n    return $98f674c4cc22e340$var$currentDecoder.copyBuffers ? // specifically use the copying slice (not the node one)\n    Uint8Array.prototype.slice.call($98f674c4cc22e340$var$src, $98f674c4cc22e340$var$position, $98f674c4cc22e340$var$position += length) : $98f674c4cc22e340$var$src.subarray($98f674c4cc22e340$var$position, $98f674c4cc22e340$var$position += length);\n}\nfunction $98f674c4cc22e340$var$readExt(length) {\n    let type = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n    if ($98f674c4cc22e340$var$currentExtensions[type]) return $98f674c4cc22e340$var$currentExtensions[type]($98f674c4cc22e340$var$src.subarray($98f674c4cc22e340$var$position, $98f674c4cc22e340$var$position += length));\n    else throw new Error(\"Unknown extension type \" + type);\n}\nlet $98f674c4cc22e340$var$f32Array = new Float32Array(1);\nlet $98f674c4cc22e340$var$u8Array = new Uint8Array($98f674c4cc22e340$var$f32Array.buffer, 0, 4);\nfunction $98f674c4cc22e340$var$getFloat16() {\n    let byte0 = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n    let byte1 = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n    let exponent = (byte0 & 0x7f) >> 2;\n    if (exponent === 0x1f) {\n        if (byte1 || byte0 & 3) return NaN;\n        return byte0 & 0x80 ? -Infinity : Infinity;\n    }\n    if (exponent === 0) {\n        // significand with 10 fractional bits and divided by 2^14\n        let abs = ((byte0 & 3) << 8 | byte1) / 16777216;\n        return byte0 & 0x80 ? -abs : abs;\n    }\n    $98f674c4cc22e340$var$u8Array[3] = byte0 & 0x80 | // sign bit\n    (exponent >> 1) + 56 // 4 of 5 of the exponent bits, re-offset-ed\n    ;\n    $98f674c4cc22e340$var$u8Array[2] = (byte0 & 7) << 5 | // last exponent bit and first two mantissa bits\n    byte1 >> 3 // next 5 bits of mantissa\n    ;\n    $98f674c4cc22e340$var$u8Array[1] = byte1 << 5; // last three bits of mantissa\n    $98f674c4cc22e340$var$u8Array[0] = 0;\n    return $98f674c4cc22e340$var$f32Array[0];\n}\nlet $98f674c4cc22e340$var$keyCache = new Array(4096);\nfunction $98f674c4cc22e340$var$readKey() {\n    let length = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n    if (length >= 0x60 && length < 0x78) {\n        // fixstr, potentially use key cache\n        length = length - 0x60;\n        if ($98f674c4cc22e340$var$srcStringEnd >= $98f674c4cc22e340$var$position) return $98f674c4cc22e340$var$srcString.slice($98f674c4cc22e340$var$position - $98f674c4cc22e340$var$srcStringStart, ($98f674c4cc22e340$var$position += length) - $98f674c4cc22e340$var$srcStringStart);\n        else if (!($98f674c4cc22e340$var$srcStringEnd == 0 && $98f674c4cc22e340$var$srcEnd < 180)) return $98f674c4cc22e340$var$readFixedString(length);\n    } else {\n        $98f674c4cc22e340$var$position--;\n        return $98f674c4cc22e340$export$aafa59e2e03f2942();\n    }\n    let key = (length << 5 ^ (length > 1 ? $98f674c4cc22e340$var$dataView.getUint16($98f674c4cc22e340$var$position) : length > 0 ? $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position] : 0)) & 0xfff;\n    let entry = $98f674c4cc22e340$var$keyCache[key];\n    let checkPosition = $98f674c4cc22e340$var$position;\n    let end = $98f674c4cc22e340$var$position + length - 3;\n    let chunk;\n    let i = 0;\n    if (entry && entry.bytes == length) {\n        while(checkPosition < end){\n            chunk = $98f674c4cc22e340$var$dataView.getUint32(checkPosition);\n            if (chunk != entry[i++]) {\n                checkPosition = 0x70000000;\n                break;\n            }\n            checkPosition += 4;\n        }\n        end += 3;\n        while(checkPosition < end){\n            chunk = $98f674c4cc22e340$var$src[checkPosition++];\n            if (chunk != entry[i++]) {\n                checkPosition = 0x70000000;\n                break;\n            }\n        }\n        if (checkPosition === end) {\n            $98f674c4cc22e340$var$position = checkPosition;\n            return entry.string;\n        }\n        end -= 3;\n        checkPosition = $98f674c4cc22e340$var$position;\n    }\n    entry = [];\n    $98f674c4cc22e340$var$keyCache[key] = entry;\n    entry.bytes = length;\n    while(checkPosition < end){\n        chunk = $98f674c4cc22e340$var$dataView.getUint32(checkPosition);\n        entry.push(chunk);\n        checkPosition += 4;\n    }\n    end += 3;\n    while(checkPosition < end){\n        chunk = $98f674c4cc22e340$var$src[checkPosition++];\n        entry.push(chunk);\n    }\n    // for small blocks, avoiding the overhead of the extract call is helpful\n    let string = length < 16 ? $98f674c4cc22e340$var$shortStringInJS(length) : $98f674c4cc22e340$var$longStringInJS(length);\n    if (string != null) return entry.string = string;\n    return entry.string = $98f674c4cc22e340$var$readFixedString(length);\n}\nclass $98f674c4cc22e340$export$3288d34c523a1192 {\n    constructor(value, tag){\n        this.value = value;\n        this.tag = tag;\n    }\n}\n$98f674c4cc22e340$var$currentExtensions[0] = (dateString)=>{\n    // string date extension\n    return new Date(dateString);\n};\n$98f674c4cc22e340$var$currentExtensions[1] = (epochSec)=>{\n    // numeric date extension\n    return new Date(Math.round(epochSec * 1000));\n};\n$98f674c4cc22e340$var$currentExtensions[2] = (buffer)=>{\n    // bigint extension\n    let value = BigInt(0);\n    for(let i = 0, l = buffer.byteLength; i < l; i++)value = BigInt(buffer[i]) + value << BigInt(8);\n    return value;\n};\n$98f674c4cc22e340$var$currentExtensions[3] = (buffer)=>{\n    // negative bigint extension\n    return BigInt(-1) - $98f674c4cc22e340$var$currentExtensions[2](buffer);\n};\n$98f674c4cc22e340$var$currentExtensions[4] = (fraction)=>{\n    // best to reparse to maintain accuracy\n    return +(fraction[1] + \"e\" + fraction[0]);\n};\n$98f674c4cc22e340$var$currentExtensions[5] = (fraction)=>{\n    // probably not sufficiently accurate\n    return fraction[1] * Math.exp(fraction[0] * Math.log(2));\n};\n// the registration of the record definition extension\nconst $98f674c4cc22e340$var$recordDefinition = (id, structure)=>{\n    id = id - 0xe000;\n    let existingStructure = $98f674c4cc22e340$var$currentStructures[id];\n    if (existingStructure && existingStructure.isShared) ($98f674c4cc22e340$var$currentStructures.restoreStructures || ($98f674c4cc22e340$var$currentStructures.restoreStructures = []))[id] = existingStructure;\n    $98f674c4cc22e340$var$currentStructures[id] = structure;\n    structure.read = $98f674c4cc22e340$var$createStructureReader(structure);\n};\n$98f674c4cc22e340$var$currentExtensions[$98f674c4cc22e340$var$LEGACY_RECORD_INLINE_ID] = (data)=>{\n    let length = data.length;\n    let structure = data[1];\n    $98f674c4cc22e340$var$recordDefinition(data[0], structure);\n    let object = {};\n    for(let i = 2; i < length; i++){\n        let key = structure[i - 2];\n        object[$98f674c4cc22e340$var$safeKey(key)] = data[i];\n    }\n    return object;\n};\n$98f674c4cc22e340$var$currentExtensions[14] = (value)=>{\n    if ($98f674c4cc22e340$var$bundledStrings) return $98f674c4cc22e340$var$bundledStrings[0].slice($98f674c4cc22e340$var$bundledStrings.position0, $98f674c4cc22e340$var$bundledStrings.position0 += value);\n    return new $98f674c4cc22e340$export$3288d34c523a1192(value, 14);\n};\n$98f674c4cc22e340$var$currentExtensions[15] = (value)=>{\n    if ($98f674c4cc22e340$var$bundledStrings) return $98f674c4cc22e340$var$bundledStrings[1].slice($98f674c4cc22e340$var$bundledStrings.position1, $98f674c4cc22e340$var$bundledStrings.position1 += value);\n    return new $98f674c4cc22e340$export$3288d34c523a1192(value, 15);\n};\nlet $98f674c4cc22e340$var$glbl = {\n    Error: Error,\n    RegExp: RegExp\n};\n$98f674c4cc22e340$var$currentExtensions[27] = (data)=>{\n    return ($98f674c4cc22e340$var$glbl[data[0]] || Error)(data[1], data[2]);\n};\nconst $98f674c4cc22e340$var$packedTable = (read)=>{\n    if ($98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++] != 0x84) throw new Error(\"Packed values structure must be followed by a 4 element array\");\n    let newPackedValues = read() // packed values\n    ;\n    $98f674c4cc22e340$var$packedValues = $98f674c4cc22e340$var$packedValues ? newPackedValues.concat($98f674c4cc22e340$var$packedValues.slice(newPackedValues.length)) : newPackedValues;\n    $98f674c4cc22e340$var$packedValues.prefixes = read();\n    $98f674c4cc22e340$var$packedValues.suffixes = read();\n    return read() // read the rump\n    ;\n};\n$98f674c4cc22e340$var$packedTable.handlesRead = true;\n$98f674c4cc22e340$var$currentExtensions[51] = $98f674c4cc22e340$var$packedTable;\n$98f674c4cc22e340$var$currentExtensions[$98f674c4cc22e340$var$PACKED_REFERENCE_TAG_ID] = (data)=>{\n    if (!$98f674c4cc22e340$var$packedValues) {\n        if ($98f674c4cc22e340$var$currentDecoder.getShared) $98f674c4cc22e340$var$loadShared();\n        else return new $98f674c4cc22e340$export$3288d34c523a1192(data, $98f674c4cc22e340$var$PACKED_REFERENCE_TAG_ID);\n    }\n    if (typeof data == \"number\") return $98f674c4cc22e340$var$packedValues[16 + (data >= 0 ? 2 * data : -2 * data - 1)];\n    throw new Error(\"No support for non-integer packed references yet\");\n};\n// The following code is an incomplete implementation of http://cbor.schmorp.de/stringref\n// the real thing would need to implemennt more logic to populate the stringRefs table and\n// maintain a stack of stringRef \"namespaces\".\n//\n// currentExtensions[25] = (id) => {\n// \treturn stringRefs[id]\n// }\n// currentExtensions[256] = (read) => {\n// \tstringRefs = []\n// \ttry {\n// \t\treturn read()\n// \t} finally {\n// \t\tstringRefs = null\n// \t}\n// }\n// currentExtensions[256].handlesRead = true\n$98f674c4cc22e340$var$currentExtensions[28] = (read)=>{\n    // shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n    if (!$98f674c4cc22e340$var$referenceMap) {\n        $98f674c4cc22e340$var$referenceMap = new Map();\n        $98f674c4cc22e340$var$referenceMap.id = 0;\n    }\n    let id = $98f674c4cc22e340$var$referenceMap.id++;\n    let token = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position];\n    let target;\n    // TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n    // ahead past references to record structure definitions\n    if (token >> 5 == 4) target = [];\n    else target = {};\n    let refEntry = {\n        target: target\n    } // a placeholder object\n    ;\n    $98f674c4cc22e340$var$referenceMap.set(id, refEntry);\n    let targetProperties = read() // read the next value as the target object to id\n    ;\n    if (refEntry.used) return Object.assign(target, targetProperties);\n    refEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one\n    ;\n    return targetProperties // no cycle, can just use the returned read object\n    ;\n};\n$98f674c4cc22e340$var$currentExtensions[28].handlesRead = true;\n$98f674c4cc22e340$var$currentExtensions[29] = (id)=>{\n    // sharedref http://cbor.schmorp.de/value-sharing (for structured clones)\n    let refEntry = $98f674c4cc22e340$var$referenceMap.get(id);\n    refEntry.used = true;\n    return refEntry.target;\n};\n$98f674c4cc22e340$var$currentExtensions[258] = (array)=>new Set(array); // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n($98f674c4cc22e340$var$currentExtensions[259] = (read)=>{\n    // https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec\n    // for decoding as a standard Map\n    if ($98f674c4cc22e340$var$currentDecoder.mapsAsObjects) {\n        $98f674c4cc22e340$var$currentDecoder.mapsAsObjects = false;\n        $98f674c4cc22e340$var$restoreMapsAsObject = true;\n    }\n    return read();\n}).handlesRead = true;\nfunction $98f674c4cc22e340$var$combine(a, b) {\n    if (typeof a === \"string\") return a + b;\n    if (a instanceof Array) return a.concat(b);\n    return Object.assign({}, a, b);\n}\nfunction $98f674c4cc22e340$var$getPackedValues() {\n    if (!$98f674c4cc22e340$var$packedValues) {\n        if ($98f674c4cc22e340$var$currentDecoder.getShared) $98f674c4cc22e340$var$loadShared();\n        else throw new Error(\"No packed values available\");\n    }\n    return $98f674c4cc22e340$var$packedValues;\n}\nconst $98f674c4cc22e340$var$SHARED_DATA_TAG_ID = 0x53687264 // ascii 'Shrd'\n;\n$98f674c4cc22e340$var$currentExtensionRanges.push((tag, input)=>{\n    if (tag >= 225 && tag <= 255) return $98f674c4cc22e340$var$combine($98f674c4cc22e340$var$getPackedValues().prefixes[tag - 224], input);\n    if (tag >= 28704 && tag <= 32767) return $98f674c4cc22e340$var$combine($98f674c4cc22e340$var$getPackedValues().prefixes[tag - 28672], input);\n    if (tag >= 1879052288 && tag <= 2147483647) return $98f674c4cc22e340$var$combine($98f674c4cc22e340$var$getPackedValues().prefixes[tag - 1879048192], input);\n    if (tag >= 216 && tag <= 223) return $98f674c4cc22e340$var$combine(input, $98f674c4cc22e340$var$getPackedValues().suffixes[tag - 216]);\n    if (tag >= 27647 && tag <= 28671) return $98f674c4cc22e340$var$combine(input, $98f674c4cc22e340$var$getPackedValues().suffixes[tag - 27639]);\n    if (tag >= 1811940352 && tag <= 1879048191) return $98f674c4cc22e340$var$combine(input, $98f674c4cc22e340$var$getPackedValues().suffixes[tag - 1811939328]);\n    if (tag == $98f674c4cc22e340$var$SHARED_DATA_TAG_ID) return {\n        packedValues: $98f674c4cc22e340$var$packedValues,\n        structures: $98f674c4cc22e340$var$currentStructures.slice(0),\n        version: input\n    };\n    if (tag == 55799) return input;\n});\nconst $98f674c4cc22e340$var$isLittleEndianMachine = new Uint8Array(new Uint16Array([\n    1\n]).buffer)[0] == 1;\nconst $98f674c4cc22e340$export$aae3eaec024a56b7 = [\n    Uint8Array,\n    Uint8ClampedArray,\n    Uint16Array,\n    Uint32Array,\n    typeof BigUint64Array == \"undefined\" ? {\n        name: \"BigUint64Array\"\n    } : BigUint64Array,\n    Int8Array,\n    Int16Array,\n    Int32Array,\n    typeof BigInt64Array == \"undefined\" ? {\n        name: \"BigInt64Array\"\n    } : BigInt64Array,\n    Float32Array,\n    Float64Array\n];\nconst $98f674c4cc22e340$var$typedArrayTags = [\n    64,\n    68,\n    69,\n    70,\n    71,\n    72,\n    77,\n    78,\n    79,\n    85,\n    86\n];\nfor(let i = 0; i < $98f674c4cc22e340$export$aae3eaec024a56b7.length; i++)$98f674c4cc22e340$var$registerTypedArray($98f674c4cc22e340$export$aae3eaec024a56b7[i], $98f674c4cc22e340$var$typedArrayTags[i]);\nfunction $98f674c4cc22e340$var$registerTypedArray(TypedArray, tag) {\n    let dvMethod = \"get\" + TypedArray.name.slice(0, -5);\n    let bytesPerElement;\n    if (typeof TypedArray === \"function\") bytesPerElement = TypedArray.BYTES_PER_ELEMENT;\n    else TypedArray = null;\n    for(let littleEndian = 0; littleEndian < 2; littleEndian++){\n        if (!littleEndian && bytesPerElement == 1) continue;\n        let sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : 3;\n        $98f674c4cc22e340$var$currentExtensions[littleEndian ? tag : tag - 4] = bytesPerElement == 1 || littleEndian == $98f674c4cc22e340$var$isLittleEndianMachine ? (buffer)=>{\n            if (!TypedArray) throw new Error(\"Could not find typed array for code \" + tag);\n            // we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned\n            return new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer);\n        } : (buffer)=>{\n            if (!TypedArray) throw new Error(\"Could not find typed array for code \" + tag);\n            let dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n            let elements = buffer.length >> sizeShift;\n            let ta = new TypedArray(elements);\n            let method = dv[dvMethod];\n            for(let i = 0; i < elements; i++)ta[i] = method.call(dv, i << sizeShift, littleEndian);\n            return ta;\n        };\n    }\n}\nfunction $98f674c4cc22e340$var$readBundleExt() {\n    let length = $98f674c4cc22e340$var$readJustLength();\n    let bundlePosition = $98f674c4cc22e340$var$position + $98f674c4cc22e340$export$aafa59e2e03f2942();\n    for(let i = 2; i < length; i++){\n        // skip past bundles that were already read\n        let bundleLength = $98f674c4cc22e340$var$readJustLength() // this will increment position, so must add to position afterwards\n        ;\n        $98f674c4cc22e340$var$position += bundleLength;\n    }\n    let dataPosition = $98f674c4cc22e340$var$position;\n    $98f674c4cc22e340$var$position = bundlePosition;\n    $98f674c4cc22e340$var$bundledStrings = [\n        $98f674c4cc22e340$var$readStringJS($98f674c4cc22e340$var$readJustLength()),\n        $98f674c4cc22e340$var$readStringJS($98f674c4cc22e340$var$readJustLength())\n    ];\n    $98f674c4cc22e340$var$bundledStrings.position0 = 0;\n    $98f674c4cc22e340$var$bundledStrings.position1 = 0;\n    $98f674c4cc22e340$var$bundledStrings.postBundlePosition = $98f674c4cc22e340$var$position;\n    $98f674c4cc22e340$var$position = dataPosition;\n    return $98f674c4cc22e340$export$aafa59e2e03f2942();\n}\nfunction $98f674c4cc22e340$var$readJustLength() {\n    let token = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++] & 0x1f;\n    if (token > 0x17) switch(token){\n        case 0x18:\n            token = $98f674c4cc22e340$var$src[$98f674c4cc22e340$var$position++];\n            break;\n        case 0x19:\n            token = $98f674c4cc22e340$var$dataView.getUint16($98f674c4cc22e340$var$position);\n            $98f674c4cc22e340$var$position += 2;\n            break;\n        case 0x1a:\n            token = $98f674c4cc22e340$var$dataView.getUint32($98f674c4cc22e340$var$position);\n            $98f674c4cc22e340$var$position += 4;\n            break;\n    }\n    return token;\n}\nfunction $98f674c4cc22e340$var$loadShared() {\n    if ($98f674c4cc22e340$var$currentDecoder.getShared) {\n        let sharedData = $98f674c4cc22e340$var$saveState(()=>{\n            // save the state in case getShared modifies our buffer\n            $98f674c4cc22e340$var$src = null;\n            return $98f674c4cc22e340$var$currentDecoder.getShared();\n        }) || {};\n        let updatedStructures = sharedData.structures || [];\n        $98f674c4cc22e340$var$currentDecoder.sharedVersion = sharedData.version;\n        $98f674c4cc22e340$var$packedValues = $98f674c4cc22e340$var$currentDecoder.sharedValues = sharedData.packedValues;\n        if ($98f674c4cc22e340$var$currentStructures === true) $98f674c4cc22e340$var$currentDecoder.structures = $98f674c4cc22e340$var$currentStructures = updatedStructures;\n        else $98f674c4cc22e340$var$currentStructures.splice.apply($98f674c4cc22e340$var$currentStructures, [\n            0,\n            updatedStructures.length\n        ].concat(updatedStructures));\n    }\n}\nfunction $98f674c4cc22e340$var$saveState(callback) {\n    let savedSrcEnd = $98f674c4cc22e340$var$srcEnd;\n    let savedPosition = $98f674c4cc22e340$var$position;\n    let savedStringPosition = $98f674c4cc22e340$var$stringPosition;\n    let savedSrcStringStart = $98f674c4cc22e340$var$srcStringStart;\n    let savedSrcStringEnd = $98f674c4cc22e340$var$srcStringEnd;\n    let savedSrcString = $98f674c4cc22e340$var$srcString;\n    let savedStrings = $98f674c4cc22e340$var$strings;\n    let savedReferenceMap = $98f674c4cc22e340$var$referenceMap;\n    let savedBundledStrings = $98f674c4cc22e340$var$bundledStrings;\n    // TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n    let savedSrc = new Uint8Array($98f674c4cc22e340$var$src.slice(0, $98f674c4cc22e340$var$srcEnd)) // we copy the data in case it changes while external data is processed\n    ;\n    let savedStructures = $98f674c4cc22e340$var$currentStructures;\n    let savedDecoder = $98f674c4cc22e340$var$currentDecoder;\n    let savedSequentialMode = $98f674c4cc22e340$var$sequentialMode;\n    let value = callback();\n    $98f674c4cc22e340$var$srcEnd = savedSrcEnd;\n    $98f674c4cc22e340$var$position = savedPosition;\n    $98f674c4cc22e340$var$stringPosition = savedStringPosition;\n    $98f674c4cc22e340$var$srcStringStart = savedSrcStringStart;\n    $98f674c4cc22e340$var$srcStringEnd = savedSrcStringEnd;\n    $98f674c4cc22e340$var$srcString = savedSrcString;\n    $98f674c4cc22e340$var$strings = savedStrings;\n    $98f674c4cc22e340$var$referenceMap = savedReferenceMap;\n    $98f674c4cc22e340$var$bundledStrings = savedBundledStrings;\n    $98f674c4cc22e340$var$src = savedSrc;\n    $98f674c4cc22e340$var$sequentialMode = savedSequentialMode;\n    $98f674c4cc22e340$var$currentStructures = savedStructures;\n    $98f674c4cc22e340$var$currentDecoder = savedDecoder;\n    $98f674c4cc22e340$var$dataView = new DataView($98f674c4cc22e340$var$src.buffer, $98f674c4cc22e340$var$src.byteOffset, $98f674c4cc22e340$var$src.byteLength);\n    return value;\n}\nfunction $98f674c4cc22e340$export$e6f020404d5b6c15() {\n    $98f674c4cc22e340$var$src = null;\n    $98f674c4cc22e340$var$referenceMap = null;\n    $98f674c4cc22e340$var$currentStructures = null;\n}\nfunction $98f674c4cc22e340$export$4e11b2f4fcd6c82d(extension) {\n    $98f674c4cc22e340$var$currentExtensions[extension.tag] = extension.decode;\n}\nconst $98f674c4cc22e340$export$c652a5bbb6be7a36 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\n;\nfor(let i = 0; i < 256; i++)$98f674c4cc22e340$export$c652a5bbb6be7a36[i] = +(\"1e\" + Math.floor(45.15 - i * 0.30103));\nlet $98f674c4cc22e340$var$defaultDecoder = new $98f674c4cc22e340$export$f9de6ca0bc043724({\n    useRecords: false\n});\nconst $98f674c4cc22e340$export$2f872c0f2117be69 = $98f674c4cc22e340$var$defaultDecoder.decode;\nconst $98f674c4cc22e340$export$ddfa300a3790ac32 = $98f674c4cc22e340$var$defaultDecoder.decodeMultiple;\nconst $98f674c4cc22e340$export$2239e49a3e351685 = {\n    NEVER: 0,\n    ALWAYS: 1,\n    DECIMAL_ROUND: 3,\n    DECIMAL_FIT: 4\n};\nfunction $98f674c4cc22e340$export$36da082398e4f139(float32Number) {\n    $98f674c4cc22e340$var$f32Array[0] = float32Number;\n    let multiplier = $98f674c4cc22e340$export$c652a5bbb6be7a36[($98f674c4cc22e340$var$u8Array[3] & 0x7f) << 1 | $98f674c4cc22e340$var$u8Array[2] >> 7];\n    return (multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5) >> 0) / multiplier;\n}\n\n\nlet $100754e509e7a4e7$var$textEncoder;\ntry {\n    $100754e509e7a4e7$var$textEncoder = new TextEncoder();\n} catch (error) {}\nlet $100754e509e7a4e7$var$extensions, $100754e509e7a4e7$var$extensionClasses;\nconst $100754e509e7a4e7$var$Buffer = typeof globalThis === \"object\" && globalThis.Buffer;\nconst $100754e509e7a4e7$var$hasNodeBuffer = typeof $100754e509e7a4e7$var$Buffer !== \"undefined\";\nconst $100754e509e7a4e7$var$ByteArrayAllocate = $100754e509e7a4e7$var$hasNodeBuffer ? $100754e509e7a4e7$var$Buffer.allocUnsafeSlow : Uint8Array;\nconst $100754e509e7a4e7$var$ByteArray = $100754e509e7a4e7$var$hasNodeBuffer ? $100754e509e7a4e7$var$Buffer : Uint8Array;\nconst $100754e509e7a4e7$var$MAX_STRUCTURES = 0x100;\nconst $100754e509e7a4e7$var$MAX_BUFFER_SIZE = $100754e509e7a4e7$var$hasNodeBuffer ? 0x100000000 : 0x7fd00000;\nlet $100754e509e7a4e7$var$serializationId = 1;\nlet $100754e509e7a4e7$var$throwOnIterable;\nlet $100754e509e7a4e7$var$target;\nlet $100754e509e7a4e7$var$targetView;\nlet $100754e509e7a4e7$var$position = 0;\nlet $100754e509e7a4e7$var$safeEnd;\nlet $100754e509e7a4e7$var$bundledStrings = null;\nconst $100754e509e7a4e7$var$MAX_BUNDLE_SIZE = 0xf000;\nconst $100754e509e7a4e7$var$hasNonLatin = /[\\u0080-\\uFFFF]/;\nconst $100754e509e7a4e7$var$RECORD_SYMBOL = Symbol(\"record-id\");\nclass $100754e509e7a4e7$export$a50aceb0e02a00aa extends (0, $98f674c4cc22e340$export$f9de6ca0bc043724) {\n    constructor(options){\n        super(options);\n        this.offset = 0;\n        let typeBuffer;\n        let start;\n        let sharedStructures;\n        let hasSharedUpdate;\n        let structures;\n        let referenceMap;\n        options = options || {};\n        let encodeUtf8 = $100754e509e7a4e7$var$ByteArray.prototype.utf8Write ? function(string, position, maxBytes) {\n            return $100754e509e7a4e7$var$target.utf8Write(string, position, maxBytes);\n        } : $100754e509e7a4e7$var$textEncoder && $100754e509e7a4e7$var$textEncoder.encodeInto ? function(string, position) {\n            return $100754e509e7a4e7$var$textEncoder.encodeInto(string, $100754e509e7a4e7$var$target.subarray(position)).written;\n        } : false;\n        let encoder = this;\n        let hasSharedStructures = options.structures || options.saveStructures;\n        let maxSharedStructures = options.maxSharedStructures;\n        if (maxSharedStructures == null) maxSharedStructures = hasSharedStructures ? 128 : 0;\n        if (maxSharedStructures > 8190) throw new Error(\"Maximum maxSharedStructure is 8190\");\n        let isSequential = options.sequential;\n        if (isSequential) maxSharedStructures = 0;\n        if (!this.structures) this.structures = [];\n        if (this.saveStructures) this.saveShared = this.saveStructures;\n        let samplingPackedValues, packedObjectMap1, sharedValues = options.sharedValues;\n        let sharedPackedObjectMap1;\n        if (sharedValues) {\n            sharedPackedObjectMap1 = Object.create(null);\n            for(let i = 0, l = sharedValues.length; i < l; i++)sharedPackedObjectMap1[sharedValues[i]] = i;\n        }\n        let recordIdsToRemove = [];\n        let transitionsCount = 0;\n        let serializationsSinceTransitionRebuild = 0;\n        this.mapEncode = function(value, encodeOptions) {\n            // Experimental support for premapping keys using _keyMap instad of keyMap - not optiimised yet)\n            if (this._keyMap && !this._mapped) //console.log('encoding ', value)\n            switch(value.constructor.name){\n                case \"Array\":\n                    value = value.map((r)=>this.encodeKeys(r));\n                    break;\n            }\n            return this.encode(value, encodeOptions);\n        };\n        this.encode = function(value, encodeOptions) {\n            if (!$100754e509e7a4e7$var$target) {\n                $100754e509e7a4e7$var$target = new $100754e509e7a4e7$var$ByteArrayAllocate(8192);\n                $100754e509e7a4e7$var$targetView = new DataView($100754e509e7a4e7$var$target.buffer, 0, 8192);\n                $100754e509e7a4e7$var$position = 0;\n            }\n            $100754e509e7a4e7$var$safeEnd = $100754e509e7a4e7$var$target.length - 10;\n            if ($100754e509e7a4e7$var$safeEnd - $100754e509e7a4e7$var$position < 0x800) {\n                // don't start too close to the end, \n                $100754e509e7a4e7$var$target = new $100754e509e7a4e7$var$ByteArrayAllocate($100754e509e7a4e7$var$target.length);\n                $100754e509e7a4e7$var$targetView = new DataView($100754e509e7a4e7$var$target.buffer, 0, $100754e509e7a4e7$var$target.length);\n                $100754e509e7a4e7$var$safeEnd = $100754e509e7a4e7$var$target.length - 10;\n                $100754e509e7a4e7$var$position = 0;\n            } else if (encodeOptions === $100754e509e7a4e7$export$d41ac1453288b342) $100754e509e7a4e7$var$position = $100754e509e7a4e7$var$position + 7 & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n            ;\n            start = $100754e509e7a4e7$var$position;\n            if (encoder.useSelfDescribedHeader) {\n                $100754e509e7a4e7$var$targetView.setUint32($100754e509e7a4e7$var$position, 0xd9d9f700) // tag two byte, then self-descriptive tag\n                ;\n                $100754e509e7a4e7$var$position += 3;\n            }\n            referenceMap = encoder.structuredClone ? new Map() : null;\n            if (encoder.bundleStrings && typeof value !== \"string\") {\n                $100754e509e7a4e7$var$bundledStrings = [];\n                $100754e509e7a4e7$var$bundledStrings.size = Infinity // force a new bundle start on first string\n                ;\n            } else $100754e509e7a4e7$var$bundledStrings = null;\n            sharedStructures = encoder.structures;\n            if (sharedStructures) {\n                if (sharedStructures.uninitialized) {\n                    let sharedData = encoder.getShared() || {};\n                    encoder.structures = sharedStructures = sharedData.structures || [];\n                    encoder.sharedVersion = sharedData.version;\n                    let sharedValues = encoder.sharedValues = sharedData.packedValues;\n                    if (sharedValues) {\n                        sharedPackedObjectMap1 = {};\n                        for(let i = 0, l = sharedValues.length; i < l; i++)sharedPackedObjectMap1[sharedValues[i]] = i;\n                    }\n                }\n                let sharedStructuresLength = sharedStructures.length;\n                if (sharedStructuresLength > maxSharedStructures && !isSequential) sharedStructuresLength = maxSharedStructures;\n                if (!sharedStructures.transitions) {\n                    // rebuild our structure transitions\n                    sharedStructures.transitions = Object.create(null);\n                    for(let i = 0; i < sharedStructuresLength; i++){\n                        let keys = sharedStructures[i];\n                        //console.log('shared struct keys:', keys)\n                        if (!keys) continue;\n                        let nextTransition, transition = sharedStructures.transitions;\n                        for(let j = 0, l = keys.length; j < l; j++){\n                            if (transition[$100754e509e7a4e7$var$RECORD_SYMBOL] === undefined) transition[$100754e509e7a4e7$var$RECORD_SYMBOL] = i;\n                            let key = keys[j];\n                            nextTransition = transition[key];\n                            if (!nextTransition) nextTransition = transition[key] = Object.create(null);\n                            transition = nextTransition;\n                        }\n                        transition[$100754e509e7a4e7$var$RECORD_SYMBOL] = i | 0x100000;\n                    }\n                }\n                if (!isSequential) sharedStructures.nextId = sharedStructuresLength;\n            }\n            if (hasSharedUpdate) hasSharedUpdate = false;\n            structures = sharedStructures || [];\n            packedObjectMap1 = sharedPackedObjectMap1;\n            if (options.pack) {\n                let packedValues = new Map();\n                packedValues.values = [];\n                packedValues.encoder = encoder;\n                packedValues.maxValues = options.maxPrivatePackedValues || (sharedPackedObjectMap1 ? 16 : Infinity);\n                packedValues.objectMap = sharedPackedObjectMap1 || false;\n                packedValues.samplingPackedValues = samplingPackedValues;\n                $100754e509e7a4e7$var$findRepetitiveStrings(value, packedValues);\n                if (packedValues.values.length > 0) {\n                    $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xd8 // one-byte tag\n                    ;\n                    $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n                    ;\n                    $100754e509e7a4e7$var$writeArrayHeader(4);\n                    let valuesArray = packedValues.values;\n                    encode(valuesArray);\n                    $100754e509e7a4e7$var$writeArrayHeader(0) // prefixes\n                    ;\n                    $100754e509e7a4e7$var$writeArrayHeader(0) // suffixes\n                    ;\n                    packedObjectMap1 = Object.create(sharedPackedObjectMap1 || null);\n                    for(let i = 0, l = valuesArray.length; i < l; i++)packedObjectMap1[valuesArray[i]] = i;\n                }\n            }\n            $100754e509e7a4e7$var$throwOnIterable = encodeOptions & $100754e509e7a4e7$export$e724ae76933ea297;\n            try {\n                if ($100754e509e7a4e7$var$throwOnIterable) return;\n                encode(value);\n                if ($100754e509e7a4e7$var$bundledStrings) $100754e509e7a4e7$var$writeBundles(start, encode);\n                encoder.offset = $100754e509e7a4e7$var$position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n                ;\n                if (referenceMap && referenceMap.idsToInsert) {\n                    $100754e509e7a4e7$var$position += referenceMap.idsToInsert.length * 2;\n                    if ($100754e509e7a4e7$var$position > $100754e509e7a4e7$var$safeEnd) makeRoom($100754e509e7a4e7$var$position);\n                    encoder.offset = $100754e509e7a4e7$var$position;\n                    let serialized = $100754e509e7a4e7$var$insertIds($100754e509e7a4e7$var$target.subarray(start, $100754e509e7a4e7$var$position), referenceMap.idsToInsert);\n                    referenceMap = null;\n                    return serialized;\n                }\n                if (encodeOptions & $100754e509e7a4e7$export$d41ac1453288b342) {\n                    $100754e509e7a4e7$var$target.start = start;\n                    $100754e509e7a4e7$var$target.end = $100754e509e7a4e7$var$position;\n                    return $100754e509e7a4e7$var$target;\n                }\n                return $100754e509e7a4e7$var$target.subarray(start, $100754e509e7a4e7$var$position) // position can change if we call encode again in saveShared, so we get the buffer now\n                ;\n            } finally{\n                if (sharedStructures) {\n                    if (serializationsSinceTransitionRebuild < 10) serializationsSinceTransitionRebuild++;\n                    if (sharedStructures.length > maxSharedStructures) sharedStructures.length = maxSharedStructures;\n                    if (transitionsCount > 10000) {\n                        // force a rebuild occasionally after a lot of transitions so it can get cleaned up\n                        sharedStructures.transitions = null;\n                        serializationsSinceTransitionRebuild = 0;\n                        transitionsCount = 0;\n                        if (recordIdsToRemove.length > 0) recordIdsToRemove = [];\n                    } else if (recordIdsToRemove.length > 0 && !isSequential) {\n                        for(let i = 0, l = recordIdsToRemove.length; i < l; i++)recordIdsToRemove[i][$100754e509e7a4e7$var$RECORD_SYMBOL] = undefined;\n                        recordIdsToRemove = [];\n                    //sharedStructures.nextId = maxSharedStructures\n                    }\n                }\n                if (hasSharedUpdate && encoder.saveShared) {\n                    if (encoder.structures.length > maxSharedStructures) encoder.structures = encoder.structures.slice(0, maxSharedStructures);\n                    // we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n                    let returnBuffer = $100754e509e7a4e7$var$target.subarray(start, $100754e509e7a4e7$var$position);\n                    if (encoder.updateSharedData() === false) return encoder.encode(value) // re-encode if it fails\n                    ;\n                    return returnBuffer;\n                }\n                if (encodeOptions & $100754e509e7a4e7$export$5687accb6effa257) $100754e509e7a4e7$var$position = start;\n            }\n        };\n        this.findCommonStringsToPack = ()=>{\n            samplingPackedValues = new Map();\n            if (!sharedPackedObjectMap1) sharedPackedObjectMap1 = Object.create(null);\n            return (options)=>{\n                let threshold = options && options.threshold || 4;\n                let position = this.pack ? options.maxPrivatePackedValues || 16 : 0;\n                if (!sharedValues) sharedValues = this.sharedValues = [];\n                for (let [key, status] of samplingPackedValues)if (status.count > threshold) {\n                    sharedPackedObjectMap1[key] = position++;\n                    sharedValues.push(key);\n                    hasSharedUpdate = true;\n                }\n                while(this.saveShared && this.updateSharedData() === false);\n                samplingPackedValues = null;\n            };\n        };\n        const encode = (value)=>{\n            if ($100754e509e7a4e7$var$position > $100754e509e7a4e7$var$safeEnd) $100754e509e7a4e7$var$target = makeRoom($100754e509e7a4e7$var$position);\n            var type = typeof value;\n            var length;\n            if (type === \"string\") {\n                if (packedObjectMap1) {\n                    let packedPosition = packedObjectMap1[value];\n                    if (packedPosition >= 0) {\n                        if (packedPosition < 16) $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = packedPosition + 0xe0 // simple values, defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n                        ;\n                        else {\n                            $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xc6 // tag 6 defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n                            ;\n                            if (packedPosition & 1) encode(15 - packedPosition >> 1);\n                            else encode(packedPosition - 16 >> 1);\n                        }\n                        return;\n                    /*\t\t\t\t\t\t} else if (packedStatus.serializationId != serializationId) {\n\t\t\t\t\t\t\tpackedStatus.serializationId = serializationId\n\t\t\t\t\t\t\tpackedStatus.count = 1\n\t\t\t\t\t\t\tif (options.sharedPack) {\n\t\t\t\t\t\t\t\tlet sharedCount = packedStatus.sharedCount = (packedStatus.sharedCount || 0) + 1\n\t\t\t\t\t\t\t\tif (shareCount > (options.sharedPack.threshold || 5)) {\n\t\t\t\t\t\t\t\t\tlet sharedPosition = packedStatus.position = packedStatus.nextSharedPosition\n\t\t\t\t\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t\t\t\t\t\tif (sharedPosition < 16)\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = sharedPosition + 0xc0\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} // else any in-doc incrementation?*/ } else if (samplingPackedValues && !options.pack) {\n                        let status = samplingPackedValues.get(value);\n                        if (status) status.count++;\n                        else samplingPackedValues.set(value, {\n                            count: 1\n                        });\n                    }\n                }\n                let strLength = value.length;\n                if ($100754e509e7a4e7$var$bundledStrings && strLength >= 4 && strLength < 0x400) {\n                    if (($100754e509e7a4e7$var$bundledStrings.size += strLength) > $100754e509e7a4e7$var$MAX_BUNDLE_SIZE) {\n                        let extStart;\n                        let maxBytes = ($100754e509e7a4e7$var$bundledStrings[0] ? $100754e509e7a4e7$var$bundledStrings[0].length * 3 + $100754e509e7a4e7$var$bundledStrings[1].length : 0) + 10;\n                        if ($100754e509e7a4e7$var$position + maxBytes > $100754e509e7a4e7$var$safeEnd) $100754e509e7a4e7$var$target = makeRoom($100754e509e7a4e7$var$position + maxBytes);\n                        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xd9 // tag 16-bit\n                        ;\n                        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xdf // tag 0xdff9\n                        ;\n                        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xf9;\n                        // TODO: If we only have one bundle with any string data, only write one string bundle\n                        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = $100754e509e7a4e7$var$bundledStrings.position ? 0x84 : 0x82 // array of 4 or 2 elements depending on if we write bundles\n                        ;\n                        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x1a // 32-bit unsigned int\n                        ;\n                        extStart = $100754e509e7a4e7$var$position - start;\n                        $100754e509e7a4e7$var$position += 4 // reserve for writing bundle reference\n                        ;\n                        if ($100754e509e7a4e7$var$bundledStrings.position) $100754e509e7a4e7$var$writeBundles(start, encode) // write the last bundles\n                        ;\n                        $100754e509e7a4e7$var$bundledStrings = [\n                            \"\",\n                            \"\"\n                        ] // create new ones\n                        ;\n                        $100754e509e7a4e7$var$bundledStrings.size = 0;\n                        $100754e509e7a4e7$var$bundledStrings.position = extStart;\n                    }\n                    let twoByte = $100754e509e7a4e7$var$hasNonLatin.test(value);\n                    $100754e509e7a4e7$var$bundledStrings[twoByte ? 0 : 1] += value;\n                    $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = twoByte ? 0xce : 0xcf;\n                    encode(strLength);\n                    return;\n                }\n                let headerSize;\n                // first we estimate the header size, so we can write to the correct location\n                if (strLength < 0x20) headerSize = 1;\n                else if (strLength < 0x100) headerSize = 2;\n                else if (strLength < 0x10000) headerSize = 3;\n                else headerSize = 5;\n                let maxBytes = strLength * 3;\n                if ($100754e509e7a4e7$var$position + maxBytes > $100754e509e7a4e7$var$safeEnd) $100754e509e7a4e7$var$target = makeRoom($100754e509e7a4e7$var$position + maxBytes);\n                if (strLength < 0x40 || !encodeUtf8) {\n                    let i, c1, c2, strPosition = $100754e509e7a4e7$var$position + headerSize;\n                    for(i = 0; i < strLength; i++){\n                        c1 = value.charCodeAt(i);\n                        if (c1 < 0x80) $100754e509e7a4e7$var$target[strPosition++] = c1;\n                        else if (c1 < 0x800) {\n                            $100754e509e7a4e7$var$target[strPosition++] = c1 >> 6 | 0xc0;\n                            $100754e509e7a4e7$var$target[strPosition++] = c1 & 0x3f | 0x80;\n                        } else if ((c1 & 0xfc00) === 0xd800 && ((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00) {\n                            c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);\n                            i++;\n                            $100754e509e7a4e7$var$target[strPosition++] = c1 >> 18 | 0xf0;\n                            $100754e509e7a4e7$var$target[strPosition++] = c1 >> 12 & 0x3f | 0x80;\n                            $100754e509e7a4e7$var$target[strPosition++] = c1 >> 6 & 0x3f | 0x80;\n                            $100754e509e7a4e7$var$target[strPosition++] = c1 & 0x3f | 0x80;\n                        } else {\n                            $100754e509e7a4e7$var$target[strPosition++] = c1 >> 12 | 0xe0;\n                            $100754e509e7a4e7$var$target[strPosition++] = c1 >> 6 & 0x3f | 0x80;\n                            $100754e509e7a4e7$var$target[strPosition++] = c1 & 0x3f | 0x80;\n                        }\n                    }\n                    length = strPosition - $100754e509e7a4e7$var$position - headerSize;\n                } else length = encodeUtf8(value, $100754e509e7a4e7$var$position + headerSize, maxBytes);\n                if (length < 0x18) $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x60 | length;\n                else if (length < 0x100) {\n                    if (headerSize < 2) $100754e509e7a4e7$var$target.copyWithin($100754e509e7a4e7$var$position + 2, $100754e509e7a4e7$var$position + 1, $100754e509e7a4e7$var$position + 1 + length);\n                    $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x78;\n                    $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = length;\n                } else if (length < 0x10000) {\n                    if (headerSize < 3) $100754e509e7a4e7$var$target.copyWithin($100754e509e7a4e7$var$position + 3, $100754e509e7a4e7$var$position + 2, $100754e509e7a4e7$var$position + 2 + length);\n                    $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x79;\n                    $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = length >> 8;\n                    $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = length & 0xff;\n                } else {\n                    if (headerSize < 5) $100754e509e7a4e7$var$target.copyWithin($100754e509e7a4e7$var$position + 5, $100754e509e7a4e7$var$position + 3, $100754e509e7a4e7$var$position + 3 + length);\n                    $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x7a;\n                    $100754e509e7a4e7$var$targetView.setUint32($100754e509e7a4e7$var$position, length);\n                    $100754e509e7a4e7$var$position += 4;\n                }\n                $100754e509e7a4e7$var$position += length;\n            } else if (type === \"number\") {\n                if (!this.alwaysUseFloat && value >>> 0 === value) {\n                    // positive uint\n                    if (value < 0x18) $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = value;\n                    else if (value < 0x100) {\n                        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x18;\n                        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = value;\n                    } else if (value < 0x10000) {\n                        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x19;\n                        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = value >> 8;\n                        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = value & 0xff;\n                    } else {\n                        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x1a;\n                        $100754e509e7a4e7$var$targetView.setUint32($100754e509e7a4e7$var$position, value);\n                        $100754e509e7a4e7$var$position += 4;\n                    }\n                } else if (!this.alwaysUseFloat && value >> 0 === value) {\n                    if (value >= -24) $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x1f - value;\n                    else if (value >= -256) {\n                        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x38;\n                        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = ~value;\n                    } else if (value >= -65536) {\n                        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x39;\n                        $100754e509e7a4e7$var$targetView.setUint16($100754e509e7a4e7$var$position, ~value);\n                        $100754e509e7a4e7$var$position += 2;\n                    } else {\n                        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x3a;\n                        $100754e509e7a4e7$var$targetView.setUint32($100754e509e7a4e7$var$position, ~value);\n                        $100754e509e7a4e7$var$position += 4;\n                    }\n                } else {\n                    let useFloat32;\n                    if ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -2147483648) {\n                        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xfa;\n                        $100754e509e7a4e7$var$targetView.setFloat32($100754e509e7a4e7$var$position, value);\n                        let xShifted;\n                        if (useFloat32 < 4 || (xShifted = value * (0, $98f674c4cc22e340$export$c652a5bbb6be7a36)[($100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position] & 0x7f) << 1 | $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position + 1] >> 7]) >> 0 === xShifted) {\n                            $100754e509e7a4e7$var$position += 4;\n                            return;\n                        } else $100754e509e7a4e7$var$position-- // move back into position for writing a double\n                        ;\n                    }\n                    $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xfb;\n                    $100754e509e7a4e7$var$targetView.setFloat64($100754e509e7a4e7$var$position, value);\n                    $100754e509e7a4e7$var$position += 8;\n                }\n            } else if (type === \"object\") {\n                if (!value) $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xf6;\n                else {\n                    if (referenceMap) {\n                        let referee = referenceMap.get(value);\n                        if (referee) {\n                            $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xd8;\n                            $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 29 // http://cbor.schmorp.de/value-sharing\n                            ;\n                            $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x19 // 16-bit uint\n                            ;\n                            if (!referee.references) {\n                                let idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = []);\n                                referee.references = [];\n                                idsToInsert.push(referee);\n                            }\n                            referee.references.push($100754e509e7a4e7$var$position - start);\n                            $100754e509e7a4e7$var$position += 2 // TODO: also support 32-bit\n                            ;\n                            return;\n                        } else referenceMap.set(value, {\n                            offset: $100754e509e7a4e7$var$position - start\n                        });\n                    }\n                    let constructor = value.constructor;\n                    if (constructor === Object) writeObject(value, true);\n                    else if (constructor === Array) {\n                        length = value.length;\n                        if (length < 0x18) $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x80 | length;\n                        else $100754e509e7a4e7$var$writeArrayHeader(length);\n                        for(let i = 0; i < length; i++)encode(value[i]);\n                    } else if (constructor === Map) {\n                        if (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {\n                            // use Tag 259 (https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec--explicit-maps.md) for maps if the user wants it that way\n                            $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xd9;\n                            $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 1;\n                            $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 3;\n                        }\n                        length = value.size;\n                        if (length < 0x18) $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xa0 | length;\n                        else if (length < 0x100) {\n                            $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xb8;\n                            $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = length;\n                        } else if (length < 0x10000) {\n                            $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xb9;\n                            $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = length >> 8;\n                            $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = length & 0xff;\n                        } else {\n                            $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xba;\n                            $100754e509e7a4e7$var$targetView.setUint32($100754e509e7a4e7$var$position, length);\n                            $100754e509e7a4e7$var$position += 4;\n                        }\n                        if (encoder.keyMap) for (let [key, entryValue] of value){\n                            encode(encoder.encodeKey(key));\n                            encode(entryValue);\n                        }\n                        else for (let [key, entryValue] of value){\n                            encode(key);\n                            encode(entryValue);\n                        }\n                    } else {\n                        for(let i = 0, l = $100754e509e7a4e7$var$extensions.length; i < l; i++){\n                            let extensionClass = $100754e509e7a4e7$var$extensionClasses[i];\n                            if (value instanceof extensionClass) {\n                                let extension = $100754e509e7a4e7$var$extensions[i];\n                                let tag = extension.tag;\n                                if (tag == undefined) tag = extension.getTag && extension.getTag.call(this, value);\n                                if (tag < 0x18) $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xc0 | tag;\n                                else if (tag < 0x100) {\n                                    $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xd8;\n                                    $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = tag;\n                                } else if (tag < 0x10000) {\n                                    $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xd9;\n                                    $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = tag >> 8;\n                                    $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = tag & 0xff;\n                                } else if (tag > -1) {\n                                    $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xda;\n                                    $100754e509e7a4e7$var$targetView.setUint32($100754e509e7a4e7$var$position, tag);\n                                    $100754e509e7a4e7$var$position += 4;\n                                } // else undefined, don't write tag\n                                extension.encode.call(this, value, encode, makeRoom);\n                                return;\n                            }\n                        }\n                        if (value[Symbol.iterator]) {\n                            if ($100754e509e7a4e7$var$throwOnIterable) {\n                                let error = new Error(\"Iterable should be serialized as iterator\");\n                                error.iteratorNotHandled = true;\n                                throw error;\n                            }\n                            $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x9f // indefinite length array\n                            ;\n                            for (let entry of value)encode(entry);\n                            $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xff // stop-code\n                            ;\n                            return;\n                        }\n                        if (value[Symbol.asyncIterator] || $100754e509e7a4e7$var$isBlob(value)) {\n                            let error = new Error(\"Iterable/blob should be serialized as iterator\");\n                            error.iteratorNotHandled = true;\n                            throw error;\n                        }\n                        if (this.useToJSON && value.toJSON) {\n                            const json = value.toJSON();\n                            // if for some reason value.toJSON returns itself it'll loop forever\n                            if (json !== value) return encode(json);\n                        }\n                        // no extension found, write as object\n                        writeObject(value, !value.hasOwnProperty) // if it doesn't have hasOwnProperty, don't do hasOwnProperty checks\n                        ;\n                    }\n                }\n            } else if (type === \"boolean\") $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = value ? 0xf5 : 0xf4;\n            else if (type === \"bigint\") {\n                if (value < BigInt(1) << BigInt(64) && value >= 0) {\n                    // use an unsigned int as long as it fits\n                    $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x1b;\n                    $100754e509e7a4e7$var$targetView.setBigUint64($100754e509e7a4e7$var$position, value);\n                } else if (value > -(BigInt(1) << BigInt(64)) && value < 0) {\n                    // if we can fit an unsigned int, use that\n                    $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x3b;\n                    $100754e509e7a4e7$var$targetView.setBigUint64($100754e509e7a4e7$var$position, -value - BigInt(1));\n                } else {\n                    // overflow\n                    if (this.largeBigIntToFloat) {\n                        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xfb;\n                        $100754e509e7a4e7$var$targetView.setFloat64($100754e509e7a4e7$var$position, Number(value));\n                    } else throw new RangeError(value + \" was too large to fit in CBOR 64-bit integer format, set largeBigIntToFloat to convert to float-64\");\n                }\n                $100754e509e7a4e7$var$position += 8;\n            } else if (type === \"undefined\") $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xf7;\n            else throw new Error(\"Unknown type: \" + type);\n        };\n        const writeObject = this.useRecords === false ? this.variableMapSize ? (object)=>{\n            // this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n            let keys = Object.keys(object);\n            let vals = Object.values(object);\n            let length = keys.length;\n            if (length < 0x18) $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xa0 | length;\n            else if (length < 0x100) {\n                $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xb8;\n                $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = length;\n            } else if (length < 0x10000) {\n                $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xb9;\n                $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = length >> 8;\n                $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = length & 0xff;\n            } else {\n                $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xba;\n                $100754e509e7a4e7$var$targetView.setUint32($100754e509e7a4e7$var$position, length);\n                $100754e509e7a4e7$var$position += 4;\n            }\n            let key;\n            if (encoder.keyMap) for(let i = 0; i < length; i++){\n                encode(encoder.encodeKey(keys[i]));\n                encode(vals[i]);\n            }\n            else for(let i = 0; i < length; i++){\n                encode(keys[i]);\n                encode(vals[i]);\n            }\n        } : (object, safePrototype)=>{\n            $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xb9 // always use map 16, so we can preallocate and set the length afterwards\n            ;\n            let objectOffset = $100754e509e7a4e7$var$position - start;\n            $100754e509e7a4e7$var$position += 2;\n            let size = 0;\n            if (encoder.keyMap) {\n                for(let key in object)if (safePrototype || object.hasOwnProperty(key)) {\n                    encode(encoder.encodeKey(key));\n                    encode(object[key]);\n                    size++;\n                }\n            } else {\n                for(let key in object)if (safePrototype || object.hasOwnProperty(key)) {\n                    encode(key);\n                    encode(object[key]);\n                    size++;\n                }\n            }\n            $100754e509e7a4e7$var$target[objectOffset++ + start] = size >> 8;\n            $100754e509e7a4e7$var$target[objectOffset + start] = size & 0xff;\n        } : (object, safePrototype)=>{\n            let nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null));\n            let newTransitions = 0;\n            let length = 0;\n            let parentRecordId;\n            let keys;\n            if (this.keyMap) {\n                keys = Object.keys(object).map((k)=>this.encodeKey(k));\n                length = keys.length;\n                for(let i = 0; i < length; i++){\n                    let key = keys[i];\n                    nextTransition = transition[key];\n                    if (!nextTransition) {\n                        nextTransition = transition[key] = Object.create(null);\n                        newTransitions++;\n                    }\n                    transition = nextTransition;\n                }\n            } else {\n                for(let key in object)if (safePrototype || object.hasOwnProperty(key)) {\n                    nextTransition = transition[key];\n                    if (!nextTransition) {\n                        if (transition[$100754e509e7a4e7$var$RECORD_SYMBOL] & 0x100000) parentRecordId = transition[$100754e509e7a4e7$var$RECORD_SYMBOL] & 0xffff;\n                        nextTransition = transition[key] = Object.create(null);\n                        newTransitions++;\n                    }\n                    transition = nextTransition;\n                    length++;\n                }\n            }\n            let recordId = transition[$100754e509e7a4e7$var$RECORD_SYMBOL];\n            if (recordId !== undefined) {\n                recordId &= 0xffff;\n                $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xd9;\n                $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = recordId >> 8 | 0xe0;\n                $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = recordId & 0xff;\n            } else {\n                if (!keys) keys = transition.__keys__ || (transition.__keys__ = Object.keys(object));\n                if (parentRecordId === undefined) {\n                    recordId = structures.nextId++;\n                    if (!recordId) {\n                        recordId = 0;\n                        structures.nextId = 1;\n                    }\n                    if (recordId >= $100754e509e7a4e7$var$MAX_STRUCTURES) structures.nextId = (recordId = maxSharedStructures) + 1;\n                } else recordId = parentRecordId;\n                structures[recordId] = keys;\n                if (recordId < maxSharedStructures) {\n                    $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xd9;\n                    $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = recordId >> 8 | 0xe0;\n                    $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = recordId & 0xff;\n                    transition = structures.transitions;\n                    for(let i = 0; i < length; i++){\n                        if (transition[$100754e509e7a4e7$var$RECORD_SYMBOL] === undefined || transition[$100754e509e7a4e7$var$RECORD_SYMBOL] & 0x100000) transition[$100754e509e7a4e7$var$RECORD_SYMBOL] = recordId;\n                        transition = transition[keys[i]];\n                    }\n                    transition[$100754e509e7a4e7$var$RECORD_SYMBOL] = recordId | 0x100000 // indicates it is a extendable terminal\n                    ;\n                    hasSharedUpdate = true;\n                } else {\n                    transition[$100754e509e7a4e7$var$RECORD_SYMBOL] = recordId;\n                    $100754e509e7a4e7$var$targetView.setUint32($100754e509e7a4e7$var$position, 0xd9dfff00) // tag two byte, then record definition id\n                    ;\n                    $100754e509e7a4e7$var$position += 3;\n                    if (newTransitions) transitionsCount += serializationsSinceTransitionRebuild * newTransitions;\n                    // record the removal of the id, we can maintain our shared structure\n                    if (recordIdsToRemove.length >= $100754e509e7a4e7$var$MAX_STRUCTURES - maxSharedStructures) recordIdsToRemove.shift()[$100754e509e7a4e7$var$RECORD_SYMBOL] = undefined // we are cycling back through, and have to remove old ones\n                    ;\n                    recordIdsToRemove.push(transition);\n                    $100754e509e7a4e7$var$writeArrayHeader(length + 2);\n                    encode(0xe000 + recordId);\n                    encode(keys);\n                    if (safePrototype === null) return; // special exit for iterator\n                    for(let key in object)if (safePrototype || object.hasOwnProperty(key)) encode(object[key]);\n                    return;\n                }\n            }\n            if (length < 0x18) $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x80 | length;\n            else $100754e509e7a4e7$var$writeArrayHeader(length);\n            if (safePrototype === null) return; // special exit for iterator\n            for(let key in object)if (safePrototype || object.hasOwnProperty(key)) encode(object[key]);\n        };\n        const makeRoom = (end)=>{\n            let newSize;\n            if (end > 0x1000000) {\n                // special handling for really large buffers\n                if (end - start > $100754e509e7a4e7$var$MAX_BUFFER_SIZE) throw new Error(\"Encoded buffer would be larger than maximum buffer size\");\n                newSize = Math.min($100754e509e7a4e7$var$MAX_BUFFER_SIZE, Math.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000);\n            } else newSize = (Math.max(end - start << 2, $100754e509e7a4e7$var$target.length - 1) >> 12) + 1 << 12;\n            let newBuffer = new $100754e509e7a4e7$var$ByteArrayAllocate(newSize);\n            $100754e509e7a4e7$var$targetView = new DataView(newBuffer.buffer, 0, newSize);\n            if ($100754e509e7a4e7$var$target.copy) $100754e509e7a4e7$var$target.copy(newBuffer, 0, start, end);\n            else newBuffer.set($100754e509e7a4e7$var$target.slice(start, end));\n            $100754e509e7a4e7$var$position -= start;\n            start = 0;\n            $100754e509e7a4e7$var$safeEnd = newBuffer.length - 10;\n            return $100754e509e7a4e7$var$target = newBuffer;\n        };\n        let chunkThreshold = 100;\n        let continuedChunkThreshold = 1000;\n        this.encodeAsIterable = function(value, options) {\n            return startEncoding(value, options, encodeObjectAsIterable);\n        };\n        this.encodeAsAsyncIterable = function(value, options) {\n            return startEncoding(value, options, encodeObjectAsAsyncIterable);\n        };\n        function* encodeObjectAsIterable(object, iterateProperties, finalIterable) {\n            let constructor = object.constructor;\n            if (constructor === Object) {\n                let useRecords = encoder.useRecords !== false;\n                if (useRecords) writeObject(object, null); // write the record identifier\n                else $100754e509e7a4e7$var$writeEntityLength(Object.keys(object).length, 0xa0);\n                for(let key in object){\n                    let value = object[key];\n                    if (!useRecords) encode(key);\n                    if (value && typeof value === \"object\") {\n                        if (iterateProperties[key]) yield* encodeObjectAsIterable(value, iterateProperties[key]);\n                        else yield* tryEncode(value, iterateProperties, key);\n                    } else encode(value);\n                }\n            } else if (constructor === Array) {\n                let length = object.length;\n                $100754e509e7a4e7$var$writeArrayHeader(length);\n                for(let i = 0; i < length; i++){\n                    let value = object[i];\n                    if (value && (typeof value === \"object\" || $100754e509e7a4e7$var$position - start > chunkThreshold)) {\n                        if (iterateProperties.element) yield* encodeObjectAsIterable(value, iterateProperties.element);\n                        else yield* tryEncode(value, iterateProperties, \"element\");\n                    } else encode(value);\n                }\n            } else if (object[Symbol.iterator]) {\n                $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x9f; // start indefinite array\n                for (let value of object)if (value && (typeof value === \"object\" || $100754e509e7a4e7$var$position - start > chunkThreshold)) {\n                    if (iterateProperties.element) yield* encodeObjectAsIterable(value, iterateProperties.element);\n                    else yield* tryEncode(value, iterateProperties, \"element\");\n                } else encode(value);\n                $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xff; // stop byte\n            } else if ($100754e509e7a4e7$var$isBlob(object)) {\n                $100754e509e7a4e7$var$writeEntityLength(object.size, 0x40); // encode as binary data\n                yield $100754e509e7a4e7$var$target.subarray(start, $100754e509e7a4e7$var$position);\n                yield object; // directly return blobs, they have to be encoded asynchronously\n                restartEncoding();\n            } else if (object[Symbol.asyncIterator]) {\n                $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x9f; // start indefinite array\n                yield $100754e509e7a4e7$var$target.subarray(start, $100754e509e7a4e7$var$position);\n                yield object; // directly return async iterators, they have to be encoded asynchronously\n                restartEncoding();\n                $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xff; // stop byte\n            } else encode(object);\n            if (finalIterable && $100754e509e7a4e7$var$position > start) yield $100754e509e7a4e7$var$target.subarray(start, $100754e509e7a4e7$var$position);\n            else if ($100754e509e7a4e7$var$position - start > chunkThreshold) {\n                yield $100754e509e7a4e7$var$target.subarray(start, $100754e509e7a4e7$var$position);\n                restartEncoding();\n            }\n        }\n        function* tryEncode(value, iterateProperties, key) {\n            let restart = $100754e509e7a4e7$var$position - start;\n            try {\n                encode(value);\n                if ($100754e509e7a4e7$var$position - start > chunkThreshold) {\n                    yield $100754e509e7a4e7$var$target.subarray(start, $100754e509e7a4e7$var$position);\n                    restartEncoding();\n                }\n            } catch (error) {\n                if (error.iteratorNotHandled) {\n                    iterateProperties[key] = {};\n                    $100754e509e7a4e7$var$position = start + restart; // restart our position so we don't have partial data from last encode\n                    yield* encodeObjectAsIterable.call(this, value, iterateProperties[key]);\n                } else throw error;\n            }\n        }\n        function restartEncoding() {\n            chunkThreshold = continuedChunkThreshold;\n            encoder.encode(null, $100754e509e7a4e7$export$e724ae76933ea297); // restart encoding\n        }\n        function startEncoding(value, options, encodeIterable) {\n            if (options && options.chunkThreshold) chunkThreshold = continuedChunkThreshold = options.chunkThreshold;\n            else chunkThreshold = 100;\n            if (value && typeof value === \"object\") {\n                encoder.encode(null, $100754e509e7a4e7$export$e724ae76933ea297); // start encoding\n                return encodeIterable(value, encoder.iterateProperties || (encoder.iterateProperties = {}), true);\n            }\n            return [\n                encoder.encode(value)\n            ];\n        }\n        async function* encodeObjectAsAsyncIterable(value, iterateProperties) {\n            for (let encodedValue of encodeObjectAsIterable(value, iterateProperties, true)){\n                let constructor = encodedValue.constructor;\n                if (constructor === $100754e509e7a4e7$var$ByteArray || constructor === Uint8Array) yield encodedValue;\n                else if ($100754e509e7a4e7$var$isBlob(encodedValue)) {\n                    let reader = encodedValue.stream().getReader();\n                    let next;\n                    while(!(next = await reader.read()).done)yield next.value;\n                } else if (encodedValue[Symbol.asyncIterator]) for await (let asyncValue of encodedValue){\n                    restartEncoding();\n                    if (asyncValue) yield* encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {}));\n                    else yield encoder.encode(asyncValue);\n                }\n                else yield encodedValue;\n            }\n        }\n    }\n    useBuffer(buffer) {\n        // this means we are finished using our own buffer and we can write over it safely\n        $100754e509e7a4e7$var$target = buffer;\n        $100754e509e7a4e7$var$targetView = new DataView($100754e509e7a4e7$var$target.buffer, $100754e509e7a4e7$var$target.byteOffset, $100754e509e7a4e7$var$target.byteLength);\n        $100754e509e7a4e7$var$position = 0;\n    }\n    clearSharedData() {\n        if (this.structures) this.structures = [];\n        if (this.sharedValues) this.sharedValues = undefined;\n    }\n    updateSharedData() {\n        let lastVersion = this.sharedVersion || 0;\n        this.sharedVersion = lastVersion + 1;\n        let structuresCopy = this.structures.slice(0);\n        let sharedData = new $100754e509e7a4e7$var$SharedData(structuresCopy, this.sharedValues, this.sharedVersion);\n        let saveResults = this.saveShared(sharedData, (existingShared)=>(existingShared && existingShared.version || 0) == lastVersion);\n        if (saveResults === false) {\n            // get updated structures and try again if the update failed\n            sharedData = this.getShared() || {};\n            this.structures = sharedData.structures || [];\n            this.sharedValues = sharedData.packedValues;\n            this.sharedVersion = sharedData.version;\n            this.structures.nextId = this.structures.length;\n        } else // restore structures\n        structuresCopy.forEach((structure, i)=>this.structures[i] = structure);\n        // saveShared may fail to write and reload, or may have reloaded to check compatibility and overwrite saved data, either way load the correct shared data\n        return saveResults;\n    }\n}\nfunction $100754e509e7a4e7$var$writeEntityLength(length, majorValue) {\n    if (length < 0x18) $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = majorValue | length;\n    else if (length < 0x100) {\n        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = majorValue | 0x18;\n        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = length;\n    } else if (length < 0x10000) {\n        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = majorValue | 0x19;\n        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = length >> 8;\n        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = length & 0xff;\n    } else {\n        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = majorValue | 0x1a;\n        $100754e509e7a4e7$var$targetView.setUint32($100754e509e7a4e7$var$position, length);\n        $100754e509e7a4e7$var$position += 4;\n    }\n}\nclass $100754e509e7a4e7$var$SharedData {\n    constructor(structures, values, version){\n        this.structures = structures;\n        this.packedValues = values;\n        this.version = version;\n    }\n}\nfunction $100754e509e7a4e7$var$writeArrayHeader(length) {\n    if (length < 0x18) $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x80 | length;\n    else if (length < 0x100) {\n        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x98;\n        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = length;\n    } else if (length < 0x10000) {\n        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x99;\n        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = length >> 8;\n        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = length & 0xff;\n    } else {\n        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x9a;\n        $100754e509e7a4e7$var$targetView.setUint32($100754e509e7a4e7$var$position, length);\n        $100754e509e7a4e7$var$position += 4;\n    }\n}\nconst $100754e509e7a4e7$var$BlobConstructor = typeof Blob === \"undefined\" ? function() {} : Blob;\nfunction $100754e509e7a4e7$var$isBlob(object) {\n    if (object instanceof $100754e509e7a4e7$var$BlobConstructor) return true;\n    let tag = object[Symbol.toStringTag];\n    return tag === \"Blob\" || tag === \"File\";\n}\nfunction $100754e509e7a4e7$var$findRepetitiveStrings(value, packedValues) {\n    switch(typeof value){\n        case \"string\":\n            if (value.length > 3) {\n                if (packedValues.objectMap[value] > -1 || packedValues.values.length >= packedValues.maxValues) return;\n                let packedStatus = packedValues.get(value);\n                if (packedStatus) {\n                    if (++packedStatus.count == 2) packedValues.values.push(value);\n                } else {\n                    packedValues.set(value, {\n                        count: 1\n                    });\n                    if (packedValues.samplingPackedValues) {\n                        let status = packedValues.samplingPackedValues.get(value);\n                        if (status) status.count++;\n                        else packedValues.samplingPackedValues.set(value, {\n                            count: 1\n                        });\n                    }\n                }\n            }\n            break;\n        case \"object\":\n            if (value) {\n                if (value instanceof Array) for(let i = 0, l = value.length; i < l; i++)$100754e509e7a4e7$var$findRepetitiveStrings(value[i], packedValues);\n                else {\n                    let includeKeys = !packedValues.encoder.useRecords;\n                    for(var key in value)if (value.hasOwnProperty(key)) {\n                        if (includeKeys) $100754e509e7a4e7$var$findRepetitiveStrings(key, packedValues);\n                        $100754e509e7a4e7$var$findRepetitiveStrings(value[key], packedValues);\n                    }\n                }\n            }\n            break;\n        case \"function\":\n            console.log(value);\n    }\n}\nconst $100754e509e7a4e7$var$isLittleEndianMachine = new Uint8Array(new Uint16Array([\n    1\n]).buffer)[0] == 1;\n$100754e509e7a4e7$var$extensionClasses = [\n    Date,\n    Set,\n    Error,\n    RegExp,\n    (0, $98f674c4cc22e340$export$3288d34c523a1192),\n    ArrayBuffer,\n    Uint8Array,\n    Uint8ClampedArray,\n    Uint16Array,\n    Uint32Array,\n    typeof BigUint64Array == \"undefined\" ? function() {} : BigUint64Array,\n    Int8Array,\n    Int16Array,\n    Int32Array,\n    typeof BigInt64Array == \"undefined\" ? function() {} : BigInt64Array,\n    Float32Array,\n    Float64Array,\n    $100754e509e7a4e7$var$SharedData\n];\n//Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/\n$100754e509e7a4e7$var$extensions = [\n    {\n        tag: 1,\n        encode (date, encode) {\n            let seconds = date.getTime() / 1000;\n            if ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n                // Timestamp 32\n                $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x1a;\n                $100754e509e7a4e7$var$targetView.setUint32($100754e509e7a4e7$var$position, seconds);\n                $100754e509e7a4e7$var$position += 4;\n            } else {\n                // Timestamp float64\n                $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xfb;\n                $100754e509e7a4e7$var$targetView.setFloat64($100754e509e7a4e7$var$position, seconds);\n                $100754e509e7a4e7$var$position += 8;\n            }\n        }\n    },\n    {\n        tag: 258,\n        encode (set, encode) {\n            let array = Array.from(set);\n            encode(array);\n        }\n    },\n    {\n        tag: 27,\n        encode (error, encode) {\n            encode([\n                error.name,\n                error.message\n            ]);\n        }\n    },\n    {\n        tag: 27,\n        encode (regex, encode) {\n            encode([\n                \"RegExp\",\n                regex.source,\n                regex.flags\n            ]);\n        }\n    },\n    {\n        getTag (tag) {\n            return tag.tag;\n        },\n        encode (tag, encode) {\n            encode(tag.value);\n        }\n    },\n    {\n        encode (arrayBuffer, encode, makeRoom) {\n            $100754e509e7a4e7$var$writeBuffer(arrayBuffer, makeRoom);\n        }\n    },\n    {\n        getTag (typedArray) {\n            if (typedArray.constructor === Uint8Array) {\n                if (this.tagUint8Array || $100754e509e7a4e7$var$hasNodeBuffer && this.tagUint8Array !== false) return 64;\n            } // else no tag\n        },\n        encode (typedArray, encode, makeRoom) {\n            $100754e509e7a4e7$var$writeBuffer(typedArray, makeRoom);\n        }\n    },\n    $100754e509e7a4e7$var$typedArrayEncoder(68, 1),\n    $100754e509e7a4e7$var$typedArrayEncoder(69, 2),\n    $100754e509e7a4e7$var$typedArrayEncoder(70, 4),\n    $100754e509e7a4e7$var$typedArrayEncoder(71, 8),\n    $100754e509e7a4e7$var$typedArrayEncoder(72, 1),\n    $100754e509e7a4e7$var$typedArrayEncoder(77, 2),\n    $100754e509e7a4e7$var$typedArrayEncoder(78, 4),\n    $100754e509e7a4e7$var$typedArrayEncoder(79, 8),\n    $100754e509e7a4e7$var$typedArrayEncoder(85, 4),\n    $100754e509e7a4e7$var$typedArrayEncoder(86, 8),\n    {\n        encode (sharedData, encode) {\n            let packedValues = sharedData.packedValues || [];\n            let sharedStructures = sharedData.structures || [];\n            if (packedValues.values.length > 0) {\n                $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0xd8 // one-byte tag\n                ;\n                $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n                ;\n                $100754e509e7a4e7$var$writeArrayHeader(4);\n                let valuesArray = packedValues.values;\n                encode(valuesArray);\n                $100754e509e7a4e7$var$writeArrayHeader(0) // prefixes\n                ;\n                $100754e509e7a4e7$var$writeArrayHeader(0) // suffixes\n                ;\n                packedObjectMap = Object.create(sharedPackedObjectMap || null);\n                for(let i = 0, l = valuesArray.length; i < l; i++)packedObjectMap[valuesArray[i]] = i;\n            }\n            if (sharedStructures) {\n                $100754e509e7a4e7$var$targetView.setUint32($100754e509e7a4e7$var$position, 0xd9dffe00);\n                $100754e509e7a4e7$var$position += 3;\n                let definitions = sharedStructures.slice(0);\n                definitions.unshift(0xe000);\n                definitions.push(new (0, $98f674c4cc22e340$export$3288d34c523a1192)(sharedData.version, 0x53687264));\n                encode(definitions);\n            } else encode(new (0, $98f674c4cc22e340$export$3288d34c523a1192)(sharedData.version, 0x53687264));\n        }\n    }\n];\nfunction $100754e509e7a4e7$var$typedArrayEncoder(tag, size) {\n    if (!$100754e509e7a4e7$var$isLittleEndianMachine && size > 1) tag -= 4 // the big endian equivalents are 4 less\n    ;\n    return {\n        tag: tag,\n        encode: function writeExtBuffer(typedArray, encode) {\n            let length = typedArray.byteLength;\n            let offset = typedArray.byteOffset || 0;\n            let buffer = typedArray.buffer || typedArray;\n            encode($100754e509e7a4e7$var$hasNodeBuffer ? $100754e509e7a4e7$var$Buffer.from(buffer, offset, length) : new Uint8Array(buffer, offset, length));\n        }\n    };\n}\nfunction $100754e509e7a4e7$var$writeBuffer(buffer, makeRoom) {\n    let length = buffer.byteLength;\n    if (length < 0x18) $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x40 + length;\n    else if (length < 0x100) {\n        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x58;\n        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = length;\n    } else if (length < 0x10000) {\n        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x59;\n        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = length >> 8;\n        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = length & 0xff;\n    } else {\n        $100754e509e7a4e7$var$target[$100754e509e7a4e7$var$position++] = 0x5a;\n        $100754e509e7a4e7$var$targetView.setUint32($100754e509e7a4e7$var$position, length);\n        $100754e509e7a4e7$var$position += 4;\n    }\n    if ($100754e509e7a4e7$var$position + length >= $100754e509e7a4e7$var$target.length) makeRoom($100754e509e7a4e7$var$position + length);\n    // if it is already a typed array (has an ArrayBuffer), use that, but if it is an ArrayBuffer itself,\n    // must wrap it to set it.\n    $100754e509e7a4e7$var$target.set(buffer.buffer ? buffer : new Uint8Array(buffer), $100754e509e7a4e7$var$position);\n    $100754e509e7a4e7$var$position += length;\n}\nfunction $100754e509e7a4e7$var$insertIds(serialized, idsToInsert) {\n    // insert the ids that need to be referenced for structured clones\n    let nextId;\n    let distanceToMove = idsToInsert.length * 2;\n    let lastEnd = serialized.length - distanceToMove;\n    idsToInsert.sort((a, b)=>a.offset > b.offset ? 1 : -1);\n    for(let id = 0; id < idsToInsert.length; id++){\n        let referee = idsToInsert[id];\n        referee.id = id;\n        for (let position of referee.references){\n            serialized[position++] = id >> 8;\n            serialized[position] = id & 0xff;\n        }\n    }\n    while(nextId = idsToInsert.pop()){\n        let offset = nextId.offset;\n        serialized.copyWithin(offset + distanceToMove, offset, lastEnd);\n        distanceToMove -= 2;\n        let position = offset + distanceToMove;\n        serialized[position++] = 0xd8;\n        serialized[position++] = 28 // http://cbor.schmorp.de/value-sharing\n        ;\n        lastEnd = offset;\n    }\n    return serialized;\n}\nfunction $100754e509e7a4e7$var$writeBundles(start, encode) {\n    $100754e509e7a4e7$var$targetView.setUint32($100754e509e7a4e7$var$bundledStrings.position + start, $100754e509e7a4e7$var$position - $100754e509e7a4e7$var$bundledStrings.position - start + 1) // the offset to bundle\n    ;\n    let writeStrings = $100754e509e7a4e7$var$bundledStrings;\n    $100754e509e7a4e7$var$bundledStrings = null;\n    encode(writeStrings[0]);\n    encode(writeStrings[1]);\n}\nfunction $100754e509e7a4e7$export$4e11b2f4fcd6c82d(extension) {\n    if (extension.Class) {\n        if (!extension.encode) throw new Error(\"Extension has no encode function\");\n        $100754e509e7a4e7$var$extensionClasses.unshift(extension.Class);\n        $100754e509e7a4e7$var$extensions.unshift(extension);\n    }\n    (0, $98f674c4cc22e340$export$4e11b2f4fcd6c82d)(extension);\n}\nlet $100754e509e7a4e7$var$defaultEncoder = new $100754e509e7a4e7$export$a50aceb0e02a00aa({\n    useRecords: false\n});\nconst $100754e509e7a4e7$export$c564cdbbe6da493 = $100754e509e7a4e7$var$defaultEncoder.encode;\nconst $100754e509e7a4e7$export$62a5d0ccbd8ba53e = $100754e509e7a4e7$var$defaultEncoder.encodeAsIterable;\nconst $100754e509e7a4e7$export$ba03bcdfc44f370a = $100754e509e7a4e7$var$defaultEncoder.encodeAsAsyncIterable;\nconst { NEVER: $100754e509e7a4e7$export$96c94437c95d7862, ALWAYS: $100754e509e7a4e7$export$9252627518dcde93, DECIMAL_ROUND: $100754e509e7a4e7$export$50de32e2440ab0bf, DECIMAL_FIT: $100754e509e7a4e7$export$fa7c7714126eb380 } = (0, $98f674c4cc22e340$export$2239e49a3e351685);\nconst $100754e509e7a4e7$export$d41ac1453288b342 = 512;\nconst $100754e509e7a4e7$export$5687accb6effa257 = 1024;\nconst $100754e509e7a4e7$export$e724ae76933ea297 = 2048;\n\n\n\n\n\n\nvar $5L6jO = parcelRequire(\"5L6jO\");\nvar $27fe39173131b88f$require$Buffer = $5L6jO.Buffer;\nfunction $27fe39173131b88f$export$82db1b517a03d6f4(objectIterator, options = {}) {\n    if (!objectIterator || typeof objectIterator !== \"object\") throw new Error(\"first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable\");\n    else if (typeof objectIterator[Symbol.iterator] === \"function\") return $27fe39173131b88f$var$encodeIterSync(objectIterator, options);\n    else if (typeof objectIterator.then === \"function\" || typeof objectIterator[Symbol.asyncIterator] === \"function\") return $27fe39173131b88f$var$encodeIterAsync(objectIterator, options);\n    else throw new Error(\"first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise\");\n}\nfunction* $27fe39173131b88f$var$encodeIterSync(objectIterator, options) {\n    const encoder = new (0, $100754e509e7a4e7$export$a50aceb0e02a00aa)(options);\n    for (const value of objectIterator)yield encoder.encode(value);\n}\nasync function* $27fe39173131b88f$var$encodeIterAsync(objectIterator, options) {\n    const encoder = new (0, $100754e509e7a4e7$export$a50aceb0e02a00aa)(options);\n    for await (const value of objectIterator)yield encoder.encode(value);\n}\nfunction $27fe39173131b88f$export$5201756020406471(bufferIterator, options = {}) {\n    if (!bufferIterator || typeof bufferIterator !== \"object\") throw new Error(\"first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise\");\n    const decoder = new (0, $98f674c4cc22e340$export$f9de6ca0bc043724)(options);\n    let incomplete;\n    const parser = (chunk)=>{\n        let yields;\n        // if there's incomplete data from previous chunk, concatinate and try again\n        if (incomplete) {\n            chunk = $27fe39173131b88f$require$Buffer.concat([\n                incomplete,\n                chunk\n            ]);\n            incomplete = undefined;\n        }\n        try {\n            yields = decoder.decodeMultiple(chunk);\n        } catch (err) {\n            if (err.incomplete) {\n                incomplete = chunk.slice(err.lastPosition);\n                yields = err.values;\n            } else throw err;\n        }\n        return yields;\n    };\n    if (typeof bufferIterator[Symbol.iterator] === \"function\") return function* iter() {\n        for (const value of bufferIterator)yield* parser(value);\n    }();\n    else if (typeof bufferIterator[Symbol.asyncIterator] === \"function\") return async function* iter() {\n        for await (const value of bufferIterator)yield* parser(value);\n    }();\n}\n\n\n\n\n\nvar $hBa25 = parcelRequire(\"hBa25\");\nconst $31a20e1f2ee0e410$var$NullValue = Symbol.for(null);\nfunction $31a20e1f2ee0e410$var$concatUint8Array(buffer1, buffer2) {\n    const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n    tmp.set(buffer1, 0);\n    tmp.set(buffer2, buffer1.byteLength);\n    return new Uint8Array(tmp.buffer);\n}\nconst $31a20e1f2ee0e410$var$iterateOver = async function*(stream) {\n    const reader = stream.getReader();\n    try {\n        while(true){\n            const { done: done, value: value } = await reader.read();\n            if (done) return;\n            yield value;\n        }\n    } finally{\n        reader.releaseLock();\n    }\n};\nclass $31a20e1f2ee0e410$export$7e9583c3c8a0a2cc extends (0, $hBa25.StreamConnection) {\n    constructor(peerId, provider, options){\n        super(peerId, provider, {\n            ...options,\n            reliable: true\n        });\n        this.serialization = \"Cbor\";\n        this._encoder = new (0, $100754e509e7a4e7$export$a50aceb0e02a00aa)();\n        this._decoder = new (0, $98f674c4cc22e340$export$f9de6ca0bc043724)();\n        this._decoderStream = new TransformStream({\n            transform: (abchunk, controller)=>{\n                let chunk = new Uint8Array(abchunk);\n                if (this._inc) {\n                    chunk = $31a20e1f2ee0e410$var$concatUint8Array(this._inc, chunk);\n                    this._inc = null;\n                }\n                let values;\n                try {\n                    values = this._decoder.decodeMultiple(chunk);\n                } catch (error) {\n                    if (error.incomplete) {\n                        this._inc = chunk.subarray(error.lastPosition);\n                        values = error.values;\n                    } else throw error;\n                } finally{\n                    for (let value of values || []){\n                        if (value === null) value = $31a20e1f2ee0e410$var$NullValue;\n                        controller.enqueue(value);\n                    }\n                }\n            }\n        });\n        this._rawReadStream.pipeTo(this._decoderStream.writable);\n        (async ()=>{\n            for await (const msg of $31a20e1f2ee0e410$var$iterateOver(this._decoderStream.readable)){\n                if (msg.__peerData?.type === \"close\") {\n                    this.close();\n                    return;\n                }\n                this.emit(\"data\", msg);\n            }\n        })();\n    }\n    _send(data) {\n        return this.writer.write(this._encoder.encode(data));\n    }\n}\n\n\nexport {$31a20e1f2ee0e410$export$7e9583c3c8a0a2cc as Cbor};\n//# sourceMappingURL=serializer.cbor.mjs.map\n","\"use strict\";","import logger from \"../../logger.js\";\nimport type { Peer } from \"../../peer.js\";\nimport { DataConnection } from \"../DataConnection.js\";\n\nexport abstract class StreamConnection extends DataConnection {\n\tprivate _CHUNK_SIZE = 1024 * 8 * 4;\n\tprivate _splitStream = new TransformStream<Uint8Array>({\n\t\ttransform: (chunk, controller) => {\n\t\t\tfor (let split = 0; split < chunk.length; split += this._CHUNK_SIZE) {\n\t\t\t\tcontroller.enqueue(chunk.subarray(split, split + this._CHUNK_SIZE));\n\t\t\t}\n\t\t},\n\t});\n\tprivate _rawSendStream = new WritableStream<ArrayBuffer>({\n\t\twrite: async (chunk, controller) => {\n\t\t\tconst openEvent = new Promise((resolve) =>\n\t\t\t\tthis.dataChannel.addEventListener(\"bufferedamountlow\", resolve, {\n\t\t\t\t\tonce: true,\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\t// if we can send the chunk now, send it\n\t\t\t// if not, we wait until at least half of the sending buffer is free again\n\t\t\tawait (this.dataChannel.bufferedAmount <=\n\t\t\t\tDataConnection.MAX_BUFFERED_AMOUNT - chunk.byteLength || openEvent);\n\n\t\t\t// TODO: what can go wrong here?\n\t\t\ttry {\n\t\t\t\tthis.dataChannel.send(chunk);\n\t\t\t} catch (e) {\n\t\t\t\tlogger.error(`DC#:${this.connectionId} Error when sending:`, e);\n\t\t\t\tcontroller.error(e);\n\t\t\t\tthis.close();\n\t\t\t}\n\t\t},\n\t});\n\tprotected writer = this._splitStream.writable.getWriter();\n\n\tprotected _rawReadStream = new ReadableStream<ArrayBuffer>({\n\t\tstart: (controller) => {\n\t\t\tthis.once(\"open\", () => {\n\t\t\t\tthis.dataChannel.addEventListener(\"message\", (e) => {\n\t\t\t\t\tcontroller.enqueue(e.data);\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\t});\n\n\tprotected constructor(peerId: string, provider: Peer, options: any) {\n\t\tsuper(peerId, provider, { ...options, reliable: true });\n\n\t\tvoid this._splitStream.readable.pipeTo(this._rawSendStream);\n\t}\n\n\tpublic override _initializeDataChannel(dc) {\n\t\tsuper._initializeDataChannel(dc);\n\t\tthis.dataChannel.binaryType = \"arraybuffer\";\n\t\tthis.dataChannel.bufferedAmountLowThreshold =\n\t\t\tDataConnection.MAX_BUFFERED_AMOUNT / 2;\n\t}\n}\n","const LOG_PREFIX = \"PeerJS: \";\n\n/*\nPrints log messages depending on the debug level passed in. Defaults to 0.\n0  Prints no logs.\n1  Prints only errors.\n2  Prints errors and warnings.\n3  Prints all logs.\n*/\nexport enum LogLevel {\n\t/**\n\t * Prints no logs.\n\t */\n\tDisabled,\n\t/**\n\t * Prints only errors.\n\t */\n\tErrors,\n\t/**\n\t * Prints errors and warnings.\n\t */\n\tWarnings,\n\t/**\n\t * Prints all logs.\n\t */\n\tAll,\n}\n\nclass Logger {\n\tprivate _logLevel = LogLevel.Disabled;\n\n\tget logLevel(): LogLevel {\n\t\treturn this._logLevel;\n\t}\n\n\tset logLevel(logLevel: LogLevel) {\n\t\tthis._logLevel = logLevel;\n\t}\n\n\tlog(...args: any[]) {\n\t\tif (this._logLevel >= LogLevel.All) {\n\t\t\tthis._print(LogLevel.All, ...args);\n\t\t}\n\t}\n\n\twarn(...args: any[]) {\n\t\tif (this._logLevel >= LogLevel.Warnings) {\n\t\t\tthis._print(LogLevel.Warnings, ...args);\n\t\t}\n\t}\n\n\terror(...args: any[]) {\n\t\tif (this._logLevel >= LogLevel.Errors) {\n\t\t\tthis._print(LogLevel.Errors, ...args);\n\t\t}\n\t}\n\n\tsetLogFunction(fn: (logLevel: LogLevel, ..._: any[]) => void): void {\n\t\tthis._print = fn;\n\t}\n\n\tprivate _print(logLevel: LogLevel, ...rest: any[]): void {\n\t\tconst copy = [LOG_PREFIX, ...rest];\n\n\t\tfor (const i in copy) {\n\t\t\tif (copy[i] instanceof Error) {\n\t\t\t\tcopy[i] = \"(\" + copy[i].name + \") \" + copy[i].message;\n\t\t\t}\n\t\t}\n\n\t\tif (logLevel >= LogLevel.All) {\n\t\t\tconsole.log(...copy);\n\t\t} else if (logLevel >= LogLevel.Warnings) {\n\t\t\tconsole.warn(\"WARNING\", ...copy);\n\t\t} else if (logLevel >= LogLevel.Errors) {\n\t\t\tconsole.error(\"ERROR\", ...copy);\n\t\t}\n\t}\n}\n\nexport default new Logger();\n","import logger from \"../logger\";\nimport { Negotiator } from \"../negotiator\";\nimport {\n\tBaseConnectionErrorType,\n\tConnectionType,\n\tDataConnectionErrorType,\n\tServerMessageType,\n} from \"../enums\";\nimport type { Peer } from \"../peer\";\nimport { BaseConnection, type BaseConnectionEvents } from \"../baseconnection\";\nimport type { ServerMessage } from \"../servermessage\";\nimport type { EventsWithError } from \"../peerError\";\nimport { randomToken } from \"../utils/randomToken\";\n\nexport interface DataConnectionEvents\n\textends EventsWithError<DataConnectionErrorType | BaseConnectionErrorType>,\n\t\tBaseConnectionEvents<DataConnectionErrorType | BaseConnectionErrorType> {\n\t/**\n\t * Emitted when data is received from the remote peer.\n\t */\n\tdata: (data: unknown) => void;\n\t/**\n\t * Emitted when the connection is established and ready-to-use.\n\t */\n\topen: () => void;\n}\n\n/**\n * Wraps a DataChannel between two Peers.\n */\nexport abstract class DataConnection extends BaseConnection<\n\tDataConnectionEvents,\n\tDataConnectionErrorType\n> {\n\tprotected static readonly ID_PREFIX = \"dc_\";\n\tprotected static readonly MAX_BUFFERED_AMOUNT = 8 * 1024 * 1024;\n\n\tprivate _negotiator: Negotiator<DataConnectionEvents, this>;\n\tabstract readonly serialization: string;\n\treadonly reliable: boolean;\n\n\tpublic get type() {\n\t\treturn ConnectionType.Data;\n\t}\n\n\tconstructor(peerId: string, provider: Peer, options: any) {\n\t\tsuper(peerId, provider, options);\n\n\t\tthis.connectionId =\n\t\t\tthis.options.connectionId || DataConnection.ID_PREFIX + randomToken();\n\n\t\tthis.label = this.options.label || this.connectionId;\n\t\tthis.reliable = !!this.options.reliable;\n\n\t\tthis._negotiator = new Negotiator(this);\n\n\t\tthis._negotiator.startConnection(\n\t\t\tthis.options._payload || {\n\t\t\t\toriginator: true,\n\t\t\t\treliable: this.reliable,\n\t\t\t},\n\t\t);\n\t}\n\n\t/** Called by the Negotiator when the DataChannel is ready. */\n\toverride _initializeDataChannel(dc: RTCDataChannel): void {\n\t\tthis.dataChannel = dc;\n\n\t\tthis.dataChannel.onopen = () => {\n\t\t\tlogger.log(`DC#${this.connectionId} dc connection success`);\n\t\t\tthis._open = true;\n\t\t\tthis.emit(\"open\");\n\t\t};\n\n\t\tthis.dataChannel.onmessage = (e) => {\n\t\t\tlogger.log(`DC#${this.connectionId} dc onmessage:`, e.data);\n\t\t\t// this._handleDataMessage(e);\n\t\t};\n\n\t\tthis.dataChannel.onclose = () => {\n\t\t\tlogger.log(`DC#${this.connectionId} dc closed for:`, this.peer);\n\t\t\tthis.close();\n\t\t};\n\t}\n\n\t/**\n\t * Exposed functionality for users.\n\t */\n\n\t/** Allows user to close connection. */\n\tclose(options?: { flush?: boolean }): void {\n\t\tif (options?.flush) {\n\t\t\tthis.send({\n\t\t\t\t__peerData: {\n\t\t\t\t\ttype: \"close\",\n\t\t\t\t},\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tif (this._negotiator) {\n\t\t\tthis._negotiator.cleanup();\n\t\t\tthis._negotiator = null;\n\t\t}\n\n\t\tif (this.provider) {\n\t\t\tthis.provider._removeConnection(this);\n\n\t\t\tthis.provider = null;\n\t\t}\n\n\t\tif (this.dataChannel) {\n\t\t\tthis.dataChannel.onopen = null;\n\t\t\tthis.dataChannel.onmessage = null;\n\t\t\tthis.dataChannel.onclose = null;\n\t\t\tthis.dataChannel = null;\n\t\t}\n\n\t\tif (!this.open) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._open = false;\n\n\t\tsuper.emit(\"close\");\n\t}\n\n\tprotected abstract _send(data: any, chunked: boolean): void | Promise<void>;\n\n\t/** Allows user to send data. */\n\tpublic send(data: any, chunked = false) {\n\t\tif (!this.open) {\n\t\t\tthis.emitError(\n\t\t\t\tDataConnectionErrorType.NotOpenYet,\n\t\t\t\t\"Connection is not open. You should listen for the `open` event before sending messages.\",\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\treturn this._send(data, chunked);\n\t}\n\n\tasync handleMessage(message: ServerMessage) {\n\t\tconst payload = message.payload;\n\n\t\tswitch (message.type) {\n\t\t\tcase ServerMessageType.Answer:\n\t\t\t\tawait this._negotiator.handleSDP(message.type, payload.sdp);\n\t\t\t\tbreak;\n\t\t\tcase ServerMessageType.Candidate:\n\t\t\t\tawait this._negotiator.handleCandidate(payload.candidate);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlogger.warn(\n\t\t\t\t\t\"Unrecognized message type:\",\n\t\t\t\t\tmessage.type,\n\t\t\t\t\t\"from peer:\",\n\t\t\t\t\tthis.peer,\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n","import logger from \"./logger\";\nimport type { MediaConnection } from \"./mediaconnection\";\nimport type { DataConnection } from \"./dataconnection/DataConnection\";\nimport {\n\tBaseConnectionErrorType,\n\tConnectionType,\n\tPeerErrorType,\n\tServerMessageType,\n} from \"./enums\";\nimport type { BaseConnection, BaseConnectionEvents } from \"./baseconnection\";\nimport type { ValidEventTypes } from \"eventemitter3\";\n\n/**\n * Manages all negotiations between Peers.\n */\nexport class Negotiator<\n\tEvents extends ValidEventTypes,\n\tConnectionType extends BaseConnection<Events | BaseConnectionEvents>,\n> {\n\tconstructor(readonly connection: ConnectionType) {}\n\n\t/** Returns a PeerConnection object set up correctly (for data, media). */\n\tstartConnection(options: any) {\n\t\tconst peerConnection = this._startPeerConnection();\n\n\t\t// Set the connection's PC.\n\t\tthis.connection.peerConnection = peerConnection;\n\n\t\tif (this.connection.type === ConnectionType.Media && options._stream) {\n\t\t\tthis._addTracksToConnection(options._stream, peerConnection);\n\t\t}\n\n\t\t// What do we need to do now?\n\t\tif (options.originator) {\n\t\t\tconst dataConnection = this.connection;\n\n\t\t\tconst config: RTCDataChannelInit = { ordered: !!options.reliable };\n\n\t\t\tconst dataChannel = peerConnection.createDataChannel(\n\t\t\t\tdataConnection.label,\n\t\t\t\tconfig,\n\t\t\t);\n\t\t\tdataConnection._initializeDataChannel(dataChannel);\n\n\t\t\tvoid this._makeOffer();\n\t\t} else {\n\t\t\tvoid this.handleSDP(\"OFFER\", options.sdp);\n\t\t}\n\t}\n\n\t/** Start a PC. */\n\tprivate _startPeerConnection(): RTCPeerConnection {\n\t\tlogger.log(\"Creating RTCPeerConnection.\");\n\n\t\tconst peerConnection = new RTCPeerConnection(\n\t\t\tthis.connection.provider.options.config,\n\t\t);\n\n\t\tthis._setupListeners(peerConnection);\n\n\t\treturn peerConnection;\n\t}\n\n\t/** Set up various WebRTC listeners. */\n\tprivate _setupListeners(peerConnection: RTCPeerConnection) {\n\t\tconst peerId = this.connection.peer;\n\t\tconst connectionId = this.connection.connectionId;\n\t\tconst connectionType = this.connection.type;\n\t\tconst provider = this.connection.provider;\n\n\t\t// ICE CANDIDATES.\n\t\tlogger.log(\"Listening for ICE candidates.\");\n\n\t\tpeerConnection.onicecandidate = (evt) => {\n\t\t\tif (!evt.candidate || !evt.candidate.candidate) return;\n\n\t\t\tlogger.log(`Received ICE candidates for ${peerId}:`, evt.candidate);\n\n\t\t\tprovider.socket.send({\n\t\t\t\ttype: ServerMessageType.Candidate,\n\t\t\t\tpayload: {\n\t\t\t\t\tcandidate: evt.candidate,\n\t\t\t\t\ttype: connectionType,\n\t\t\t\t\tconnectionId: connectionId,\n\t\t\t\t},\n\t\t\t\tdst: peerId,\n\t\t\t});\n\t\t};\n\n\t\tpeerConnection.oniceconnectionstatechange = () => {\n\t\t\tswitch (peerConnection.iceConnectionState) {\n\t\t\t\tcase \"failed\":\n\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\"iceConnectionState is failed, closing connections to \" + peerId,\n\t\t\t\t\t);\n\t\t\t\t\tthis.connection.emitError(\n\t\t\t\t\t\tBaseConnectionErrorType.NegotiationFailed,\n\t\t\t\t\t\t\"Negotiation of connection to \" + peerId + \" failed.\",\n\t\t\t\t\t);\n\t\t\t\t\tthis.connection.close();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"closed\":\n\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\"iceConnectionState is closed, closing connections to \" + peerId,\n\t\t\t\t\t);\n\t\t\t\t\tthis.connection.emitError(\n\t\t\t\t\t\tBaseConnectionErrorType.ConnectionClosed,\n\t\t\t\t\t\t\"Connection to \" + peerId + \" closed.\",\n\t\t\t\t\t);\n\t\t\t\t\tthis.connection.close();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"disconnected\":\n\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\"iceConnectionState changed to disconnected on the connection with \" +\n\t\t\t\t\t\t\tpeerId,\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"completed\":\n\t\t\t\t\tpeerConnection.onicecandidate = () => {};\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tthis.connection.emit(\n\t\t\t\t\"iceStateChanged\",\n\t\t\t\tpeerConnection.iceConnectionState,\n\t\t\t);\n\t\t};\n\n\t\t// DATACONNECTION.\n\t\tlogger.log(\"Listening for data channel\");\n\t\t// Fired between offer and answer, so options should already be saved\n\t\t// in the options hash.\n\t\tpeerConnection.ondatachannel = (evt) => {\n\t\t\tlogger.log(\"Received data channel\");\n\n\t\t\tconst dataChannel = evt.channel;\n\t\t\tconst connection = <DataConnection>(\n\t\t\t\tprovider.getConnection(peerId, connectionId)\n\t\t\t);\n\n\t\t\tconnection._initializeDataChannel(dataChannel);\n\t\t};\n\n\t\t// MEDIACONNECTION.\n\t\tlogger.log(\"Listening for remote stream\");\n\n\t\tpeerConnection.ontrack = (evt) => {\n\t\t\tlogger.log(\"Received remote stream\");\n\n\t\t\tconst stream = evt.streams[0];\n\t\t\tconst connection = provider.getConnection(peerId, connectionId);\n\n\t\t\tif (connection.type === ConnectionType.Media) {\n\t\t\t\tconst mediaConnection = <MediaConnection>connection;\n\n\t\t\t\tthis._addStreamToMediaConnection(stream, mediaConnection);\n\t\t\t}\n\t\t};\n\t}\n\n\tcleanup(): void {\n\t\tlogger.log(\"Cleaning up PeerConnection to \" + this.connection.peer);\n\n\t\tconst peerConnection = this.connection.peerConnection;\n\n\t\tif (!peerConnection) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.connection.peerConnection = null;\n\n\t\t//unsubscribe from all PeerConnection's events\n\t\tpeerConnection.onicecandidate =\n\t\t\tpeerConnection.oniceconnectionstatechange =\n\t\t\tpeerConnection.ondatachannel =\n\t\t\tpeerConnection.ontrack =\n\t\t\t\t() => {};\n\n\t\tconst peerConnectionNotClosed = peerConnection.signalingState !== \"closed\";\n\t\tlet dataChannelNotClosed = false;\n\n\t\tconst dataChannel = this.connection.dataChannel;\n\n\t\tif (dataChannel) {\n\t\t\tdataChannelNotClosed =\n\t\t\t\t!!dataChannel.readyState && dataChannel.readyState !== \"closed\";\n\t\t}\n\n\t\tif (peerConnectionNotClosed || dataChannelNotClosed) {\n\t\t\tpeerConnection.close();\n\t\t}\n\t}\n\n\tprivate async _makeOffer(): Promise<void> {\n\t\tconst peerConnection = this.connection.peerConnection;\n\t\tconst provider = this.connection.provider;\n\n\t\ttry {\n\t\t\tconst offer = await peerConnection.createOffer(\n\t\t\t\tthis.connection.options.constraints,\n\t\t\t);\n\n\t\t\tlogger.log(\"Created offer.\");\n\n\t\t\tif (\n\t\t\t\tthis.connection.options.sdpTransform &&\n\t\t\t\ttypeof this.connection.options.sdpTransform === \"function\"\n\t\t\t) {\n\t\t\t\toffer.sdp =\n\t\t\t\t\tthis.connection.options.sdpTransform(offer.sdp) || offer.sdp;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tawait peerConnection.setLocalDescription(offer);\n\n\t\t\t\tlogger.log(\n\t\t\t\t\t\"Set localDescription:\",\n\t\t\t\t\toffer,\n\t\t\t\t\t`for:${this.connection.peer}`,\n\t\t\t\t);\n\n\t\t\t\tlet payload: any = {\n\t\t\t\t\tsdp: offer,\n\t\t\t\t\ttype: this.connection.type,\n\t\t\t\t\tconnectionId: this.connection.connectionId,\n\t\t\t\t\tmetadata: this.connection.metadata,\n\t\t\t\t};\n\n\t\t\t\tif (this.connection.type === ConnectionType.Data) {\n\t\t\t\t\tconst dataConnection = <DataConnection>(<unknown>this.connection);\n\n\t\t\t\t\tpayload = {\n\t\t\t\t\t\t...payload,\n\t\t\t\t\t\tlabel: dataConnection.label,\n\t\t\t\t\t\treliable: dataConnection.reliable,\n\t\t\t\t\t\tserialization: dataConnection.serialization,\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tprovider.socket.send({\n\t\t\t\t\ttype: ServerMessageType.Offer,\n\t\t\t\t\tpayload,\n\t\t\t\t\tdst: this.connection.peer,\n\t\t\t\t});\n\t\t\t} catch (err) {\n\t\t\t\t// TODO: investigate why _makeOffer is being called from the answer\n\t\t\t\tif (\n\t\t\t\t\terr !=\n\t\t\t\t\t\"OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer\"\n\t\t\t\t) {\n\t\t\t\t\tprovider.emitError(PeerErrorType.WebRTC, err);\n\t\t\t\t\tlogger.log(\"Failed to setLocalDescription, \", err);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err_1) {\n\t\t\tprovider.emitError(PeerErrorType.WebRTC, err_1);\n\t\t\tlogger.log(\"Failed to createOffer, \", err_1);\n\t\t}\n\t}\n\n\tprivate async _makeAnswer(): Promise<void> {\n\t\tconst peerConnection = this.connection.peerConnection;\n\t\tconst provider = this.connection.provider;\n\n\t\ttry {\n\t\t\tconst answer = await peerConnection.createAnswer();\n\t\t\tlogger.log(\"Created answer.\");\n\n\t\t\tif (\n\t\t\t\tthis.connection.options.sdpTransform &&\n\t\t\t\ttypeof this.connection.options.sdpTransform === \"function\"\n\t\t\t) {\n\t\t\t\tanswer.sdp =\n\t\t\t\t\tthis.connection.options.sdpTransform(answer.sdp) || answer.sdp;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tawait peerConnection.setLocalDescription(answer);\n\n\t\t\t\tlogger.log(\n\t\t\t\t\t`Set localDescription:`,\n\t\t\t\t\tanswer,\n\t\t\t\t\t`for:${this.connection.peer}`,\n\t\t\t\t);\n\n\t\t\t\tprovider.socket.send({\n\t\t\t\t\ttype: ServerMessageType.Answer,\n\t\t\t\t\tpayload: {\n\t\t\t\t\t\tsdp: answer,\n\t\t\t\t\t\ttype: this.connection.type,\n\t\t\t\t\t\tconnectionId: this.connection.connectionId,\n\t\t\t\t\t},\n\t\t\t\t\tdst: this.connection.peer,\n\t\t\t\t});\n\t\t\t} catch (err) {\n\t\t\t\tprovider.emitError(PeerErrorType.WebRTC, err);\n\t\t\t\tlogger.log(\"Failed to setLocalDescription, \", err);\n\t\t\t}\n\t\t} catch (err_1) {\n\t\t\tprovider.emitError(PeerErrorType.WebRTC, err_1);\n\t\t\tlogger.log(\"Failed to create answer, \", err_1);\n\t\t}\n\t}\n\n\t/** Handle an SDP. */\n\tasync handleSDP(type: string, sdp: any): Promise<void> {\n\t\tsdp = new RTCSessionDescription(sdp);\n\t\tconst peerConnection = this.connection.peerConnection;\n\t\tconst provider = this.connection.provider;\n\n\t\tlogger.log(\"Setting remote description\", sdp);\n\n\t\tconst self = this;\n\n\t\ttry {\n\t\t\tawait peerConnection.setRemoteDescription(sdp);\n\t\t\tlogger.log(`Set remoteDescription:${type} for:${this.connection.peer}`);\n\t\t\tif (type === \"OFFER\") {\n\t\t\t\tawait self._makeAnswer();\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tprovider.emitError(PeerErrorType.WebRTC, err);\n\t\t\tlogger.log(\"Failed to setRemoteDescription, \", err);\n\t\t}\n\t}\n\n\t/** Handle a candidate. */\n\tasync handleCandidate(ice: RTCIceCandidate) {\n\t\tlogger.log(`handleCandidate:`, ice);\n\n\t\ttry {\n\t\t\tawait this.connection.peerConnection.addIceCandidate(ice);\n\t\t\tlogger.log(`Added ICE candidate for:${this.connection.peer}`);\n\t\t} catch (err) {\n\t\t\tthis.connection.provider.emitError(PeerErrorType.WebRTC, err);\n\t\t\tlogger.log(\"Failed to handleCandidate, \", err);\n\t\t}\n\t}\n\n\tprivate _addTracksToConnection(\n\t\tstream: MediaStream,\n\t\tpeerConnection: RTCPeerConnection,\n\t): void {\n\t\tlogger.log(`add tracks from stream ${stream.id} to peer connection`);\n\n\t\tif (!peerConnection.addTrack) {\n\t\t\treturn logger.error(\n\t\t\t\t`Your browser does't support RTCPeerConnection#addTrack. Ignored.`,\n\t\t\t);\n\t\t}\n\n\t\tstream.getTracks().forEach((track) => {\n\t\t\tpeerConnection.addTrack(track, stream);\n\t\t});\n\t}\n\n\tprivate _addStreamToMediaConnection(\n\t\tstream: MediaStream,\n\t\tmediaConnection: MediaConnection,\n\t): void {\n\t\tlogger.log(\n\t\t\t`add stream ${stream.id} to media connection ${mediaConnection.connectionId}`,\n\t\t);\n\n\t\tmediaConnection.addStream(stream);\n\t}\n}\n","export enum ConnectionType {\n\tData = \"data\",\n\tMedia = \"media\",\n}\n\nexport enum PeerErrorType {\n\t/**\n\t * The client's browser does not support some or all WebRTC features that you are trying to use.\n\t */\n\tBrowserIncompatible = \"browser-incompatible\",\n\t/**\n\t * You've already disconnected this peer from the server and can no longer make any new connections on it.\n\t */\n\tDisconnected = \"disconnected\",\n\t/**\n\t * The ID passed into the Peer constructor contains illegal characters.\n\t */\n\tInvalidID = \"invalid-id\",\n\t/**\n\t * The API key passed into the Peer constructor contains illegal characters or is not in the system (cloud server only).\n\t */\n\tInvalidKey = \"invalid-key\",\n\t/**\n\t * Lost or cannot establish a connection to the signalling server.\n\t */\n\tNetwork = \"network\",\n\t/**\n\t * The peer you're trying to connect to does not exist.\n\t */\n\tPeerUnavailable = \"peer-unavailable\",\n\t/**\n\t * PeerJS is being used securely, but the cloud server does not support SSL. Use a custom PeerServer.\n\t */\n\tSslUnavailable = \"ssl-unavailable\",\n\t/**\n\t * Unable to reach the server.\n\t */\n\tServerError = \"server-error\",\n\t/**\n\t * An error from the underlying socket.\n\t */\n\tSocketError = \"socket-error\",\n\t/**\n\t * The underlying socket closed unexpectedly.\n\t */\n\tSocketClosed = \"socket-closed\",\n\t/**\n\t * The ID passed into the Peer constructor is already taken.\n\t *\n\t * :::caution\n\t * This error is not fatal if your peer has open peer-to-peer connections.\n\t * This can happen if you attempt to {@apilink Peer.reconnect} a peer that has been disconnected from the server,\n\t * but its old ID has now been taken.\n\t * :::\n\t */\n\tUnavailableID = \"unavailable-id\",\n\t/**\n\t * Native WebRTC errors.\n\t */\n\tWebRTC = \"webrtc\",\n}\n\nexport enum BaseConnectionErrorType {\n\tNegotiationFailed = \"negotiation-failed\",\n\tConnectionClosed = \"connection-closed\",\n}\n\nexport enum DataConnectionErrorType {\n\tNotOpenYet = \"not-open-yet\",\n\tMessageToBig = \"message-too-big\",\n}\n\nexport enum SerializationType {\n\tBinary = \"binary\",\n\tBinaryUTF8 = \"binary-utf8\",\n\tJSON = \"json\",\n\tNone = \"raw\",\n}\n\nexport enum SocketEventType {\n\tMessage = \"message\",\n\tDisconnected = \"disconnected\",\n\tError = \"error\",\n\tClose = \"close\",\n}\n\nexport enum ServerMessageType {\n\tHeartbeat = \"HEARTBEAT\",\n\tCandidate = \"CANDIDATE\",\n\tOffer = \"OFFER\",\n\tAnswer = \"ANSWER\",\n\tOpen = \"OPEN\", // The connection to the server is open.\n\tError = \"ERROR\", // Server error.\n\tIdTaken = \"ID-TAKEN\", // The selected ID is taken.\n\tInvalidKey = \"INVALID-KEY\", // The given API key cannot be found.\n\tLeave = \"LEAVE\", // Another peer has closed its connection to this peer.\n\tExpire = \"EXPIRE\", // The offer sent to a peer has expired without response.\n}\n","import type { Peer } from \"./peer\";\nimport type { ServerMessage } from \"./servermessage\";\nimport type { ConnectionType } from \"./enums\";\nimport { BaseConnectionErrorType } from \"./enums\";\nimport {\n\tEventEmitterWithError,\n\ttype EventsWithError,\n\tPeerError,\n} from \"./peerError\";\nimport type { ValidEventTypes } from \"eventemitter3\";\n\nexport interface BaseConnectionEvents<\n\tErrorType extends string = BaseConnectionErrorType,\n> extends EventsWithError<ErrorType> {\n\t/**\n\t * Emitted when either you or the remote peer closes the connection.\n\t *\n\t * ```ts\n\t * connection.on('close', () => { ... });\n\t * ```\n\t */\n\tclose: () => void;\n\t/**\n\t * ```ts\n\t * connection.on('error', (error) => { ... });\n\t * ```\n\t */\n\terror: (error: PeerError<`${ErrorType}`>) => void;\n\ticeStateChanged: (state: RTCIceConnectionState) => void;\n}\n\nexport abstract class BaseConnection<\n\tSubClassEvents extends ValidEventTypes,\n\tErrorType extends string = never,\n> extends EventEmitterWithError<\n\tErrorType | BaseConnectionErrorType,\n\tSubClassEvents & BaseConnectionEvents<BaseConnectionErrorType | ErrorType>\n> {\n\tprotected _open = false;\n\n\t/**\n\t * Any type of metadata associated with the connection,\n\t * passed in by whoever initiated the connection.\n\t */\n\treadonly metadata: any;\n\tconnectionId: string;\n\n\tpeerConnection: RTCPeerConnection;\n\tdataChannel: RTCDataChannel;\n\n\tabstract get type(): ConnectionType;\n\n\t/**\n\t * The optional label passed in or assigned by PeerJS when the connection was initiated.\n\t */\n\tlabel: string;\n\n\t/**\n\t * Whether the media connection is active (e.g. your call has been answered).\n\t * You can check this if you want to set a maximum wait time for a one-sided call.\n\t */\n\tget open() {\n\t\treturn this._open;\n\t}\n\n\tprotected constructor(\n\t\t/**\n\t\t * The ID of the peer on the other end of this connection.\n\t\t */\n\t\treadonly peer: string,\n\t\tpublic provider: Peer,\n\t\treadonly options: any,\n\t) {\n\t\tsuper();\n\n\t\tthis.metadata = options.metadata;\n\t}\n\n\tabstract close(): void;\n\n\t/**\n\t * @internal\n\t */\n\tabstract handleMessage(message: ServerMessage): void;\n\n\t/**\n\t * Called by the Negotiator when the DataChannel is ready.\n\t * @internal\n\t * */\n\tabstract _initializeDataChannel(dc: RTCDataChannel): void;\n}\n","import { EventEmitter } from \"eventemitter3\";\nimport logger from \"./logger\";\n\nexport interface EventsWithError<ErrorType extends string> {\n\terror: (error: PeerError<`${ErrorType}`>) => void;\n}\n\nexport class EventEmitterWithError<\n\tErrorType extends string,\n\tEvents extends EventsWithError<ErrorType>,\n> extends EventEmitter<Events, never> {\n\t/**\n\t * Emits a typed error message.\n\t *\n\t * @internal\n\t */\n\temitError(type: ErrorType, err: string | Error): void {\n\t\tlogger.error(\"Error:\", err);\n\n\t\t// @ts-ignore\n\t\tthis.emit(\"error\", new PeerError<`${ErrorType}`>(`${type}`, err));\n\t}\n}\n/**\n * A PeerError is emitted whenever an error occurs.\n * It always has a `.type`, which can be used to identify the error.\n */\nexport class PeerError<T extends string> extends Error {\n\t/**\n\t * @internal\n\t */\n\tconstructor(type: T, err: Error | string) {\n\t\tif (typeof err === \"string\") {\n\t\t\tsuper(err);\n\t\t} else {\n\t\t\tsuper();\n\t\t\tObject.assign(this, err);\n\t\t}\n\n\t\tthis.type = type;\n\t}\n\n\tpublic type: T;\n}\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","export const randomToken = () => Math.random().toString(36).slice(2);\n","import type { Peer } from \"../../peer.js\";\nimport { Decoder, Encoder } from \"cbor-x\";\nimport { StreamConnection } from \"./StreamConnection.js\";\n\nconst NullValue = Symbol.for(null);\n\nfunction concatUint8Array(buffer1: Uint8Array, buffer2: Uint8Array) {\n\tconst tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n\ttmp.set(buffer1, 0);\n\ttmp.set(buffer2, buffer1.byteLength);\n\treturn new Uint8Array(tmp.buffer);\n}\n\nconst iterateOver = async function* (stream: ReadableStream) {\n\tconst reader = stream.getReader();\n\ttry {\n\t\twhile (true) {\n\t\t\tconst { done, value } = await reader.read();\n\t\t\tif (done) return;\n\t\t\tyield value;\n\t\t}\n\t} finally {\n\t\treader.releaseLock();\n\t}\n};\n\nexport class Cbor extends StreamConnection {\n\treadonly serialization = \"Cbor\";\n\tprivate _encoder = new Encoder();\n\tprivate _decoder = new Decoder();\n\tprivate _inc;\n\tprivate _decoderStream = new TransformStream<ArrayBuffer, unknown>({\n\t\ttransform: (abchunk, controller) => {\n\t\t\tlet chunk = new Uint8Array(abchunk);\n\t\t\tif (this._inc) {\n\t\t\t\tchunk = concatUint8Array(this._inc, chunk);\n\t\t\t\tthis._inc = null;\n\t\t\t}\n\t\t\tlet values;\n\t\t\ttry {\n\t\t\t\tvalues = this._decoder.decodeMultiple(chunk);\n\t\t\t} catch (error) {\n\t\t\t\tif (error.incomplete) {\n\t\t\t\t\tthis._inc = chunk.subarray(error.lastPosition);\n\t\t\t\t\tvalues = error.values;\n\t\t\t\t} else throw error;\n\t\t\t} finally {\n\t\t\t\tfor (let value of values || []) {\n\t\t\t\t\tif (value === null) value = NullValue;\n\t\t\t\t\tcontroller.enqueue(value);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t});\n\n\tconstructor(peerId: string, provider: Peer, options: any) {\n\t\tsuper(peerId, provider, { ...options, reliable: true });\n\n\t\tvoid this._rawReadStream.pipeTo(this._decoderStream.writable);\n\n\t\t(async () => {\n\t\t\tfor await (const msg of iterateOver(this._decoderStream.readable)) {\n\t\t\t\tif (msg.__peerData?.type === \"close\") {\n\t\t\t\t\tthis.close();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.emit(\"data\", msg);\n\t\t\t}\n\t\t})();\n\t}\n\n\tprotected override _send(data) {\n\t\treturn this.writer.write(this._encoder.encode(data));\n\t}\n}\n","export { Encoder, addExtension, encode, encodeAsIterable, encodeAsAsyncIterable, NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT, REUSE_BUFFER_MODE } from './encode.js'\nexport { Tag, Decoder, decodeMultiple, decode, FLOAT32_OPTIONS, clearSource, roundFloat32, isNativeAccelerationEnabled } from './decode.js'\nexport { decodeIter, encodeIter } from './iterators.js'\n","import { Decoder, mult10, Tag, typedArrays, addExtension as decodeAddExtension } from './decode.js'\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions, extensionClasses\nconst Buffer = typeof globalThis === 'object' && globalThis.Buffer;\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ? Buffer.allocUnsafeSlow : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_STRUCTURES = 0x100\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nlet serializationId = 1\nlet throwOnIterable\nlet target\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nconst MAX_BUNDLE_SIZE = 0xf000\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nconst RECORD_SYMBOL = Symbol('record-id')\nexport class Encoder extends Decoder {\n\tconstructor(options) {\n\t\tsuper(options)\n\t\tthis.offset = 0\n\t\tlet typeBuffer\n\t\tlet start\n\t\tlet sharedStructures\n\t\tlet hasSharedUpdate\n\t\tlet structures\n\t\tlet referenceMap\n\t\toptions = options || {}\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position, maxBytes) {\n\t\t\treturn target.utf8Write(string, position, maxBytes)\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false\n\n\t\tlet encoder = this\n\t\tlet hasSharedStructures = options.structures || options.saveStructures\n\t\tlet maxSharedStructures = options.maxSharedStructures\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 128 : 0\n\t\tif (maxSharedStructures > 8190)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8190')\n\t\tlet isSequential = options.sequential\n\t\tif (isSequential) {\n\t\t\tmaxSharedStructures = 0\n\t\t}\n\t\tif (!this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.saveStructures)\n\t\t\tthis.saveShared = this.saveStructures\n\t\tlet samplingPackedValues, packedObjectMap, sharedValues = options.sharedValues\n\t\tlet sharedPackedObjectMap\n\t\tif (sharedValues) {\n\t\t\tsharedPackedObjectMap = Object.create(null)\n\t\t\tfor (let i = 0, l = sharedValues.length; i < l; i++) {\n\t\t\t\tsharedPackedObjectMap[sharedValues[i]] = i\n\t\t\t}\n\t\t}\n\t\tlet recordIdsToRemove = []\n\t\tlet transitionsCount = 0\n\t\tlet serializationsSinceTransitionRebuild = 0\n\t\t\n\t\tthis.mapEncode = function(value, encodeOptions) {\n\t\t\t// Experimental support for premapping keys using _keyMap instad of keyMap - not optiimised yet)\n\t\t\tif (this._keyMap && !this._mapped) {\n\t\t\t\t//console.log('encoding ', value)\n\t\t\t\tswitch (value.constructor.name) {\n\t\t\t\t\tcase 'Array': \n\t\t\t\t\t\tvalue = value.map(r => this.encodeKeys(r))\n\t\t\t\t\t\tbreak\n\t\t\t\t\t//case 'Map': \n\t\t\t\t\t//\tvalue = this.encodeKeys(value)\n\t\t\t\t\t//\tbreak\n\t\t\t\t}\n\t\t\t\t//this._mapped = true\n\t\t\t}\n\t\t\treturn this.encode(value, encodeOptions)\n\t\t}\n\t\t\n\t\tthis.encode = function(value, encodeOptions)\t{\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\n\t\t\t\ttargetView = new DataView(target.buffer, 0, 8192)\n\t\t\t\tposition = 0\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end, \n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\n\t\t\t\ttargetView = new DataView(target.buffer, 0, target.length)\n\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\tposition = 0\n\t\t\t} else if (encodeOptions === REUSE_BUFFER_MODE)\n\t\t\t\tposition = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n\t\t\tstart = position\n\t\t\tif (encoder.useSelfDescribedHeader) {\n\t\t\t\ttargetView.setUint32(position, 0xd9d9f700) // tag two byte, then self-descriptive tag\n\t\t\t\tposition += 3\n\t\t\t}\n\t\t\treferenceMap = encoder.structuredClone ? new Map() : null\n\t\t\tif (encoder.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = []\n\t\t\t\tbundledStrings.size = Infinity // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null\n\n\t\t\tsharedStructures = encoder.structures\n\t\t\tif (sharedStructures) {\n\t\t\t\tif (sharedStructures.uninitialized) {\n\t\t\t\t\tlet sharedData = encoder.getShared() || {}\n\t\t\t\t\tencoder.structures = sharedStructures = sharedData.structures || []\n\t\t\t\t\tencoder.sharedVersion = sharedData.version\n\t\t\t\t\tlet sharedValues = encoder.sharedValues = sharedData.packedValues\n\t\t\t\t\tif (sharedValues) {\n\t\t\t\t\t\tsharedPackedObjectMap = {}\n\t\t\t\t\t\tfor (let i = 0, l = sharedValues.length; i < l; i++)\n\t\t\t\t\t\t\tsharedPackedObjectMap[sharedValues[i]] = i\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet sharedStructuresLength = sharedStructures.length\n\t\t\t\tif (sharedStructuresLength > maxSharedStructures && !isSequential)\n\t\t\t\t\tsharedStructuresLength = maxSharedStructures\n\t\t\t\tif (!sharedStructures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tsharedStructures.transitions = Object.create(null)\n\t\t\t\t\tfor (let i = 0; i < sharedStructuresLength; i++) {\n\t\t\t\t\t\tlet keys = sharedStructures[i]\n\t\t\t\t\t\t//console.log('shared struct keys:', keys)\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = sharedStructures.transitions\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tif (transition[RECORD_SYMBOL] === undefined)\n\t\t\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i\n\t\t\t\t\t\t\tlet key = keys[j]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i | 0x100000\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!isSequential)\n\t\t\t\t\tsharedStructures.nextId = sharedStructuresLength\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false\n\t\t\tstructures = sharedStructures || []\n\t\t\tpackedObjectMap = sharedPackedObjectMap\n\t\t\tif (options.pack) {\n\t\t\t\tlet packedValues = new Map()\n\t\t\t\tpackedValues.values = []\n\t\t\t\tpackedValues.encoder = encoder\n\t\t\t\tpackedValues.maxValues = options.maxPrivatePackedValues || (sharedPackedObjectMap ? 16 : Infinity)\n\t\t\t\tpackedValues.objectMap = sharedPackedObjectMap || false\n\t\t\t\tpackedValues.samplingPackedValues = samplingPackedValues\n\t\t\t\tfindRepetitiveStrings(value, packedValues)\n\t\t\t\tif (packedValues.values.length > 0) {\n\t\t\t\t\ttarget[position++] = 0xd8 // one-byte tag\n\t\t\t\t\ttarget[position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\twriteArrayHeader(4)\n\t\t\t\t\tlet valuesArray = packedValues.values\n\t\t\t\t\tencode(valuesArray)\n\t\t\t\t\twriteArrayHeader(0) // prefixes\n\t\t\t\t\twriteArrayHeader(0) // suffixes\n\t\t\t\t\tpackedObjectMap = Object.create(sharedPackedObjectMap || null)\n\t\t\t\t\tfor (let i = 0, l = valuesArray.length; i < l; i++) {\n\t\t\t\t\t\tpackedObjectMap[valuesArray[i]] = i\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrowOnIterable = encodeOptions & THROW_ON_ITERABLE;\n\t\t\ttry {\n\t\t\t\tif (throwOnIterable)\n\t\t\t\t\treturn;\n\t\t\t\tencode(value)\n\t\t\t\tif (bundledStrings) {\n\t\t\t\t\twriteBundles(start, encode)\n\t\t\t\t}\n\t\t\t\tencoder.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tposition += referenceMap.idsToInsert.length * 2\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\tencoder.offset = position\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), referenceMap.idsToInsert)\n\t\t\t\t\treferenceMap = null\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start\n\t\t\t\t\ttarget.end = position\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call encode again in saveShared, so we get the buffer now\n\t\t\t} finally {\n\t\t\t\tif (sharedStructures) {\n\t\t\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\t\t\tserializationsSinceTransitionRebuild++\n\t\t\t\t\tif (sharedStructures.length > maxSharedStructures)\n\t\t\t\t\t\tsharedStructures.length = maxSharedStructures\n\t\t\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\t\t\tsharedStructures.transitions = null\n\t\t\t\t\t\tserializationsSinceTransitionRebuild = 0\n\t\t\t\t\t\ttransitionsCount = 0\n\t\t\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = undefined\n\t\t\t\t\t\t}\n\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t\t//sharedStructures.nextId = maxSharedStructures\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (hasSharedUpdate && encoder.saveShared) {\n\t\t\t\t\tif (encoder.structures.length > maxSharedStructures) {\n\t\t\t\t\t\tencoder.structures = encoder.structures.slice(0, maxSharedStructures)\n\t\t\t\t\t}\n\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\tlet returnBuffer = target.subarray(start, position)\n\t\t\t\t\tif (encoder.updateSharedData() === false)\n\t\t\t\t\t\treturn encoder.encode(value) // re-encode if it fails\n\t\t\t\t\treturn returnBuffer\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start\n\t\t\t}\n\t\t}\n\t\tthis.findCommonStringsToPack = () => {\n\t\t\tsamplingPackedValues = new Map()\n\t\t\tif (!sharedPackedObjectMap)\n\t\t\t\tsharedPackedObjectMap = Object.create(null)\n\t\t\treturn (options) => {\n\t\t\t\tlet threshold = options && options.threshold || 4\n\t\t\t\tlet position = this.pack ? options.maxPrivatePackedValues || 16 : 0\n\t\t\t\tif (!sharedValues)\n\t\t\t\t\tsharedValues = this.sharedValues = []\n\t\t\t\tfor (let [ key, status ] of samplingPackedValues) {\n\t\t\t\t\tif (status.count > threshold) {\n\t\t\t\t\t\tsharedPackedObjectMap[key] = position++\n\t\t\t\t\t\tsharedValues.push(key)\n\t\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (this.saveShared && this.updateSharedData() === false) {}\n\t\t\t\tsamplingPackedValues = null\n\t\t\t}\n\t\t}\n\t\tconst encode = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position)\n\n\t\t\tvar type = typeof value\n\t\t\tvar length\n\t\t\tif (type === 'string') {\n\t\t\t\tif (packedObjectMap) {\n\t\t\t\t\tlet packedPosition = packedObjectMap[value]\n\t\t\t\t\tif (packedPosition >= 0) {\n\t\t\t\t\t\tif (packedPosition < 16)\n\t\t\t\t\t\t\ttarget[position++] = packedPosition + 0xe0 // simple values, defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttarget[position++] = 0xc6 // tag 6 defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\t\t\tif (packedPosition & 1)\n\t\t\t\t\t\t\t\tencode((15 - packedPosition) >> 1)\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tencode((packedPosition - 16) >> 1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n/*\t\t\t\t\t\t} else if (packedStatus.serializationId != serializationId) {\n\t\t\t\t\t\t\tpackedStatus.serializationId = serializationId\n\t\t\t\t\t\t\tpackedStatus.count = 1\n\t\t\t\t\t\t\tif (options.sharedPack) {\n\t\t\t\t\t\t\t\tlet sharedCount = packedStatus.sharedCount = (packedStatus.sharedCount || 0) + 1\n\t\t\t\t\t\t\t\tif (shareCount > (options.sharedPack.threshold || 5)) {\n\t\t\t\t\t\t\t\t\tlet sharedPosition = packedStatus.position = packedStatus.nextSharedPosition\n\t\t\t\t\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t\t\t\t\t\tif (sharedPosition < 16)\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = sharedPosition + 0xc0\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} // else any in-doc incrementation?*/\n\t\t\t\t\t} else if (samplingPackedValues && !options.pack) {\n\t\t\t\t\t\tlet status = samplingPackedValues.get(value)\n\t\t\t\t\t\tif (status)\n\t\t\t\t\t\t\tstatus.count++\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsamplingPackedValues.set(value, {\n\t\t\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet strLength = value.length\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x400) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\t\t\t\t\t\ttarget[position++] = 0xd9 // tag 16-bit\n\t\t\t\t\t\ttarget[position++] = 0xdf // tag 0xdff9\n\t\t\t\t\t\ttarget[position++] = 0xf9\n\t\t\t\t\t\t// TODO: If we only have one bundle with any string data, only write one string bundle\n\t\t\t\t\t\ttarget[position++] = bundledStrings.position ? 0x84 : 0x82 // array of 4 or 2 elements depending on if we write bundles\n\t\t\t\t\t\ttarget[position++] = 0x1a // 32-bit unsigned int\n\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\tif (bundledStrings.position) {\n\t\t\t\t\t\t\twriteBundles(start, encode) // write the last bundles\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', ''] // create new ones\n\t\t\t\t\t\tbundledStrings.size = 0\n\t\t\t\t\t\tbundledStrings.position = extStart\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value)\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value\n\t\t\t\t\ttarget[position++] = twoByte ? 0xce : 0xcf\n\t\t\t\t\tencode(strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize, maxBytes)\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x18) {\n\t\t\t\t\ttarget[position++] = 0x60 | length\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x78\n\t\t\t\t\ttarget[position++] = length\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x79\n\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x7a\n\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\tposition += 4\n\t\t\t\t}\n\t\t\t\tposition += length\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (!this.alwaysUseFloat && value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x18) {\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0x18\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0x19\n\t\t\t\t\t\ttarget[position++] = value >> 8\n\t\t\t\t\t\ttarget[position++] = value & 0xff\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0x1a\n\t\t\t\t\t\ttargetView.setUint32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else if (!this.alwaysUseFloat && value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x18) {\n\t\t\t\t\t\ttarget[position++] = 0x1f - value\n\t\t\t\t\t} else if (value >= -0x100) {\n\t\t\t\t\t\ttarget[position++] = 0x38\n\t\t\t\t\t\ttarget[position++] = ~value\n\t\t\t\t\t} else if (value >= -0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0x39\n\t\t\t\t\t\ttargetView.setUint16(position, ~value)\n\t\t\t\t\t\tposition += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0x3a\n\t\t\t\t\t\ttargetView.setUint32(position, ~value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xfa\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xfb\n\t\t\t\t\ttargetView.setFloat64(position, value)\n\t\t\t\t\tposition += 8\n\t\t\t\t}\n\t\t\t} else if (type === 'object') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xf6\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\ttarget[position++] = 0xd8\n\t\t\t\t\t\t\ttarget[position++] = 29 // http://cbor.schmorp.de/value-sharing\n\t\t\t\t\t\t\ttarget[position++] = 0x19 // 16-bit uint\n\t\t\t\t\t\t\tif (!referee.references) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n\t\t\t\t\t\t\t\treferee.references = []\n\t\t\t\t\t\t\t\tidsToInsert.push(referee)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treferee.references.push(position - start)\n\t\t\t\t\t\t\tposition += 2 // TODO: also support 32-bit\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else \n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value, true)\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tlength = value.length\n\t\t\t\t\t\tif (length < 0x18) {\n\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twriteArrayHeader(length)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\t\t\tencode(value[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tif (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {\n\t\t\t\t\t\t\t// use Tag 259 (https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec--explicit-maps.md) for maps if the user wants it that way\n\t\t\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\t\t\ttarget[position++] = 1\n\t\t\t\t\t\t\ttarget[position++] = 3\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlength = value.size\n\t\t\t\t\t\tif (length < 0x18) {\n\t\t\t\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\t\t\ttarget[position++] = 0xb8\n\t\t\t\t\t\t\ttarget[position++] = length\n\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\ttarget[position++] = 0xb9\n\t\t\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[position++] = 0xba\n\t\t\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (encoder.keyMap) { \n\t\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\n\t\t\t\t\t\t\t\tencode(encoder.encodeKey(key))\n\t\t\t\t\t\t\t\tencode(entryValue)\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t} else { \n\t\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\n\t\t\t\t\t\t\t\tencode(key) \n\t\t\t\t\t\t\t\tencode(entryValue)\n\t\t\t\t\t\t\t} \t\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\n\t\t\t\t\t\t\t\tlet tag = extension.tag\n\t\t\t\t\t\t\t\tif (tag == undefined)\n\t\t\t\t\t\t\t\t\ttag = extension.getTag && extension.getTag.call(this, value)\n\t\t\t\t\t\t\t\tif (tag < 0x18) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xc0 | tag\n\t\t\t\t\t\t\t\t} else if (tag < 0x100) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd8\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag\n\t\t\t\t\t\t\t\t} else if (tag < 0x10000) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag >> 8\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag & 0xff\n\t\t\t\t\t\t\t\t} else if (tag > -1) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xda\n\t\t\t\t\t\t\t\t\ttargetView.setUint32(position, tag)\n\t\t\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\t\t} // else undefined, don't write tag\n\t\t\t\t\t\t\t\textension.encode.call(this, value, encode, makeRoom)\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value[Symbol.iterator]) {\n\t\t\t\t\t\t\tif (throwOnIterable) {\n\t\t\t\t\t\t\t\tlet error = new Error('Iterable should be serialized as iterator')\n\t\t\t\t\t\t\t\terror.iteratorNotHandled = true;\n\t\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0x9f // indefinite length array\n\t\t\t\t\t\t\tfor (let entry of value) {\n\t\t\t\t\t\t\t\tencode(entry)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xff // stop-code\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value[Symbol.asyncIterator] || isBlob(value)) {\n\t\t\t\t\t\t\tlet error = new Error('Iterable/blob should be serialized as iterator')\n\t\t\t\t\t\t\terror.iteratorNotHandled = true;\n\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this.useToJSON && value.toJSON) {\n\t\t\t\t\t\t\tconst json = value.toJSON()\n\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n\t\t\t\t\t\t\tif (json !== value)\n\t\t\t\t\t\t\t\treturn encode(json)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// no extension found, write as object\n\t\t\t\t\t\twriteObject(value, !value.hasOwnProperty) // if it doesn't have hasOwnProperty, don't do hasOwnProperty checks\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xf5 : 0xf4\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < (BigInt(1)<<BigInt(64)) && value >= 0) {\n\t\t\t\t\t// use an unsigned int as long as it fits\n\t\t\t\t\ttarget[position++] = 0x1b\n\t\t\t\t\ttargetView.setBigUint64(position, value)\n\t\t\t\t} else if (value > -(BigInt(1)<<BigInt(64)) && value < 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0x3b\n\t\t\t\t\ttargetView.setBigUint64(position, -value - BigInt(1))\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xfb\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RangeError(value + ' was too large to fit in CBOR 64-bit integer format, set largeBigIntToFloat to convert to float-64')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\ttarget[position++] = 0xf7\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t}\n\n\t\tconst writeObject = this.useRecords === false ? this.variableMapSize ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys = Object.keys(object)\n\t\t\tlet vals = Object.values(object)\n\t\t\tlet length = keys.length\n\t\t\tif (length < 0x18) {\n\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t} else if (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xb8\n\t\t\t\ttarget[position++] = length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xb9\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xba\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tlet key\n\t\t\tif (encoder.keyMap) { \n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tencode(encoder.encodeKey(keys[i]))\n\t\t\t\t\tencode(vals[i])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tencode(keys[i])\n\t\t\t\t\tencode(vals[i])\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\t\t(object, safePrototype) => {\n\t\t\ttarget[position++] = 0xb9 // always use map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start\n\t\t\tposition += 2\n\t\t\tlet size = 0\n\t\t\tif (encoder.keyMap) { \n\t\t\t\tfor (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tencode(encoder.encodeKey(key))\n\t\t\t\t\tencode(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t} else { \n\t\t\t\tfor (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\t\tencode(key)\n\t\t\t\t\t\tencode(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8\n\t\t\ttarget[objectOffset + start] = size & 0xff\n\t\t} :\n\t\t(object, safePrototype) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet newTransitions = 0\n\t\t\tlet length = 0\n\t\t\tlet parentRecordId\n\t\t\tlet keys\n\t\t\tif (this.keyMap) {\n\t\t\t\tkeys = Object.keys(object).map(k => this.encodeKey(k))\n\t\t\t\tlength = keys.length\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tlet key = keys[i]\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t}\n\t\t\t\t\ttransition = nextTransition\n\t\t\t\t}\t\t\t\t\n\t\t\t} else {\n\t\t\t\tfor (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\tif (transition[RECORD_SYMBOL] & 0x100000) {// this indicates it is a brancheable/extendable terminal node, so we will use this record id and extend it\n\t\t\t\t\t\t\tparentRecordId = transition[RECORD_SYMBOL] & 0xffff\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t}\n\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\tlength++\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\tif (recordId !== undefined) {\n\t\t\t\trecordId &= 0xffff\n\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\ttarget[position++] = (recordId >> 8) | 0xe0\n\t\t\t\ttarget[position++] = recordId & 0xff\n\t\t\t} else {\n\t\t\t\tif (!keys)\n\t\t\t\t\tkeys = transition.__keys__ || (transition.__keys__ = Object.keys(object))\n\t\t\t\tif (parentRecordId === undefined) {\n\t\t\t\t\trecordId = structures.nextId++\n\t\t\t\t\tif (!recordId) {\n\t\t\t\t\t\trecordId = 0\n\t\t\t\t\t\tstructures.nextId = 1\n\t\t\t\t\t}\n\t\t\t\t\tif (recordId >= MAX_STRUCTURES) {// cycle back around\n\t\t\t\t\t\tstructures.nextId = (recordId = maxSharedStructures) + 1\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trecordId = parentRecordId\n\t\t\t\t}\n\t\t\t\tstructures[recordId] = keys\n\t\t\t\tif (recordId < maxSharedStructures) {\n\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\ttarget[position++] = (recordId >> 8) | 0xe0\n\t\t\t\t\ttarget[position++] = recordId & 0xff\n\t\t\t\t\ttransition = structures.transitions\n\t\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\t\tif (transition[RECORD_SYMBOL] === undefined || (transition[RECORD_SYMBOL] & 0x100000))\n\t\t\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\t\t\t\ttransition = transition[keys[i]]\n\t\t\t\t\t}\n\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId | 0x100000 // indicates it is a extendable terminal\n\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t} else {\n\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\t\t\ttargetView.setUint32(position, 0xd9dfff00) // tag two byte, then record definition id\n\t\t\t\t\tposition += 3\n\t\t\t\t\tif (newTransitions)\n\t\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\n\t\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\t\tif (recordIdsToRemove.length >= MAX_STRUCTURES - maxSharedStructures)\n\t\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = undefined // we are cycling back through, and have to remove old ones\n\t\t\t\t\trecordIdsToRemove.push(transition)\n\t\t\t\t\twriteArrayHeader(length + 2)\n\t\t\t\t\tencode(0xe000 + recordId)\n\t\t\t\t\tencode(keys)\n\t\t\t\t\tif (safePrototype === null) return; // special exit for iterator\n\t\t\t\t\tfor (let key in object)\n\t\t\t\t\t\tif (safePrototype || object.hasOwnProperty(key))\n\t\t\t\t\t\t\tencode(object[key])\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (length < 0x18) { // write the array header\n\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t} else {\n\t\t\t\twriteArrayHeader(length)\n\t\t\t}\n\t\t\tif (safePrototype === null) return; // special exit for iterator\n\t\t\tfor (let key in object)\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key))\n\t\t\t\t\tencode(object[key])\n\t\t}\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Encoded buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\n\t\t\ttargetView = new DataView(newBuffer.buffer, 0, newSize)\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end))\n\t\t\tposition -= start\n\t\t\tstart = 0\n\t\t\tsafeEnd = newBuffer.length - 10\n\t\t\treturn target = newBuffer\n\t\t}\n\t\tlet chunkThreshold = 100;\n\t\tlet continuedChunkThreshold = 1000;\n\t\tthis.encodeAsIterable = function(value, options) {\n\t\t\treturn startEncoding(value, options, encodeObjectAsIterable);\n\t\t}\n\t\tthis.encodeAsAsyncIterable = function(value, options) {\n\t\t\treturn startEncoding(value, options, encodeObjectAsAsyncIterable);\n\t\t}\n\n\t\tfunction* encodeObjectAsIterable(object, iterateProperties, finalIterable) {\n\t\t\tlet constructor = object.constructor;\n\t\t\tif (constructor === Object) {\n\t\t\t\tlet useRecords = encoder.useRecords !== false;\n\t\t\t\tif (useRecords)\n\t\t\t\t\twriteObject(object, null); // write the record identifier\n\t\t\t\telse\n\t\t\t\t\twriteEntityLength(Object.keys(object).length, 0xa0);\n\t\t\t\tfor (let key in object) {\n\t\t\t\t\tlet value = object[key];\n\t\t\t\t\tif (!useRecords) encode(key);\n\t\t\t\t\tif (value && typeof value === 'object') {\n\t\t\t\t\t\tif (iterateProperties[key])\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties[key]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, key);\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t} else if (constructor === Array) {\n\t\t\t\tlet length = object.length;\n\t\t\t\twriteArrayHeader(length);\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tlet value = object[i];\n\t\t\t\t\tif (value && (typeof value === 'object' || position - start > chunkThreshold)) {\n\t\t\t\t\t\tif (iterateProperties.element)\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties.element);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, 'element');\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t} else if (object[Symbol.iterator]) {\n\t\t\t\ttarget[position++] = 0x9f; // start indefinite array\n\t\t\t\tfor (let value of object) {\n\t\t\t\t\tif (value && (typeof value === 'object' || position - start > chunkThreshold)) {\n\t\t\t\t\t\tif (iterateProperties.element)\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties.element);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, 'element');\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t\ttarget[position++] = 0xff; // stop byte\n\t\t\t} else if (isBlob(object)){\n\t\t\t\twriteEntityLength(object.size, 0x40); // encode as binary data\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\tyield object; // directly return blobs, they have to be encoded asynchronously\n\t\t\t\trestartEncoding();\n\t\t\t} else if (object[Symbol.asyncIterator]) {\n\t\t\t\ttarget[position++] = 0x9f; // start indefinite array\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\tyield object; // directly return async iterators, they have to be encoded asynchronously\n\t\t\t\trestartEncoding();\n\t\t\t\ttarget[position++] = 0xff; // stop byte\n\t\t\t} else {\n\t\t\t\tencode(object);\n\t\t\t}\n\t\t\tif (finalIterable && position > start) yield target.subarray(start, position);\n\t\t\telse if (position - start > chunkThreshold) {\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\trestartEncoding();\n\t\t\t}\n\t\t}\n\t\tfunction* tryEncode(value, iterateProperties, key) {\n\t\t\tlet restart = position - start;\n\t\t\ttry {\n\t\t\t\tencode(value);\n\t\t\t\tif (position - start > chunkThreshold) {\n\t\t\t\t\tyield target.subarray(start, position);\n\t\t\t\t\trestartEncoding();\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (error.iteratorNotHandled) {\n\t\t\t\t\titerateProperties[key] = {};\n\t\t\t\t\tposition = start + restart; // restart our position so we don't have partial data from last encode\n\t\t\t\t\tyield* encodeObjectAsIterable.call(this, value, iterateProperties[key]);\n\t\t\t\t} else throw error;\n\t\t\t}\n\t\t}\n\t\tfunction restartEncoding() {\n\t\t\tchunkThreshold = continuedChunkThreshold;\n\t\t\tencoder.encode(null, THROW_ON_ITERABLE); // restart encoding\n\t\t}\n\t\tfunction startEncoding(value, options, encodeIterable) {\n\t\t\tif (options && options.chunkThreshold) // explicitly specified chunk sizes\n\t\t\t\tchunkThreshold = continuedChunkThreshold = options.chunkThreshold;\n\t\t\telse // we start with a smaller threshold to get initial bytes sent quickly\n\t\t\t\tchunkThreshold = 100;\n\t\t\tif (value && typeof value === 'object') {\n\t\t\t\tencoder.encode(null, THROW_ON_ITERABLE); // start encoding\n\t\t\t\treturn encodeIterable(value, encoder.iterateProperties || (encoder.iterateProperties = {}), true);\n\t\t\t}\n\t\t\treturn [encoder.encode(value)];\n\t\t}\n\n\t\tasync function* encodeObjectAsAsyncIterable(value, iterateProperties) {\n\t\t\tfor (let encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {\n\t\t\t\tlet constructor = encodedValue.constructor;\n\t\t\t\tif (constructor === ByteArray || constructor === Uint8Array)\n\t\t\t\t\tyield encodedValue;\n\t\t\t\telse if (isBlob(encodedValue)) {\n\t\t\t\t\tlet reader = encodedValue.stream().getReader();\n\t\t\t\t\tlet next;\n\t\t\t\t\twhile (!(next = await reader.read()).done) {\n\t\t\t\t\t\tyield next.value;\n\t\t\t\t\t}\n\t\t\t\t} else if (encodedValue[Symbol.asyncIterator]) {\n\t\t\t\t\tfor await (let asyncValue of encodedValue) {\n\t\t\t\t\t\trestartEncoding();\n\t\t\t\t\t\tif (asyncValue)\n\t\t\t\t\t\t\tyield* encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {}));\n\t\t\t\t\t\telse yield encoder.encode(asyncValue);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tyield encodedValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer\n\t\ttargetView = new DataView(target.buffer, target.byteOffset, target.byteLength)\n\t\tposition = 0\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.sharedValues)\n\t\t\tthis.sharedValues = undefined\n\t}\n\tupdateSharedData() {\n\t\tlet lastVersion = this.sharedVersion || 0\n\t\tthis.sharedVersion = lastVersion + 1\n\t\tlet structuresCopy = this.structures.slice(0)\n\t\tlet sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion)\n\t\tlet saveResults = this.saveShared(sharedData,\n\t\t\t\texistingShared => (existingShared && existingShared.version || 0) == lastVersion)\n\t\tif (saveResults === false) {\n\t\t\t// get updated structures and try again if the update failed\n\t\t\tsharedData = this.getShared() || {}\n\t\t\tthis.structures = sharedData.structures || []\n\t\t\tthis.sharedValues = sharedData.packedValues\n\t\t\tthis.sharedVersion = sharedData.version\n\t\t\tthis.structures.nextId = this.structures.length\n\t\t} else {\n\t\t\t// restore structures\n\t\t\tstructuresCopy.forEach((structure, i) => this.structures[i] = structure)\n\t\t}\n\t\t// saveShared may fail to write and reload, or may have reloaded to check compatibility and overwrite saved data, either way load the correct shared data\n\t\treturn saveResults\n\t}\n}\nfunction writeEntityLength(length, majorValue) {\n\tif (length < 0x18)\n\t\ttarget[position++] = majorValue | length\n\telse if (length < 0x100) {\n\t\ttarget[position++] = majorValue | 0x18\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = majorValue | 0x19\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = majorValue | 0x1a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\n}\nclass SharedData {\n\tconstructor(structures, values, version) {\n\t\tthis.structures = structures\n\t\tthis.packedValues = values\n\t\tthis.version = version\n\t}\n}\n\nfunction writeArrayHeader(length) {\n\tif (length < 0x18)\n\t\ttarget[position++] = 0x80 | length\n\telse if (length < 0x100) {\n\t\ttarget[position++] = 0x98\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = 0x99\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = 0x9a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n}\n\nconst BlobConstructor = typeof Blob === 'undefined' ? function(){} : Blob;\nfunction isBlob(object) {\n\tif (object instanceof BlobConstructor)\n\t\treturn true;\n\tlet tag = object[Symbol.toStringTag];\n\treturn tag === 'Blob' || tag === 'File';\n}\nfunction findRepetitiveStrings(value, packedValues) {\n\tswitch(typeof value) {\n\t\tcase 'string':\n\t\t\tif (value.length > 3) {\n\t\t\t\tif (packedValues.objectMap[value] > -1 || packedValues.values.length >= packedValues.maxValues)\n\t\t\t\t\treturn\n\t\t\t\tlet packedStatus = packedValues.get(value)\n\t\t\t\tif (packedStatus) {\n\t\t\t\t\tif (++packedStatus.count == 2) {\n\t\t\t\t\t\tpackedValues.values.push(value)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpackedValues.set(value, {\n\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t})\n\t\t\t\t\tif (packedValues.samplingPackedValues) {\n\t\t\t\t\t\tlet status = packedValues.samplingPackedValues.get(value)\n\t\t\t\t\t\tif (status)\n\t\t\t\t\t\t\tstatus.count++\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpackedValues.samplingPackedValues.set(value, {\n\t\t\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'object':\n\t\t\tif (value) {\n\t\t\t\tif (value instanceof Array) {\n\t\t\t\t\tfor (let i = 0, l = value.length; i < l; i++) {\n\t\t\t\t\t\tfindRepetitiveStrings(value[i], packedValues)\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tlet includeKeys = !packedValues.encoder.useRecords\n\t\t\t\t\tfor (var key in value) {\n\t\t\t\t\t\tif (value.hasOwnProperty(key)) {\n\t\t\t\t\t\t\tif (includeKeys)\n\t\t\t\t\t\t\t\tfindRepetitiveStrings(key, packedValues)\n\t\t\t\t\t\t\tfindRepetitiveStrings(value[key], packedValues)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'function': console.log(value)\n\t}\n}\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1\nextensionClasses = [ Date, Set, Error, RegExp, Tag, ArrayBuffer,\n\tUint8Array, Uint8ClampedArray, Uint16Array, Uint32Array,\n\ttypeof BigUint64Array == 'undefined' ? function() {} : BigUint64Array, Int8Array, Int16Array, Int32Array,\n\ttypeof BigInt64Array == 'undefined' ? function() {} : BigInt64Array,\n\tFloat32Array, Float64Array, SharedData ]\n\n//Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/\nextensions = [{ // Date\n\ttag: 1,\n\tencode(date, encode) {\n\t\tlet seconds = date.getTime() / 1000\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\ttarget[position++] = 0x1a\n\t\t\ttargetView.setUint32(position, seconds)\n\t\t\tposition += 4\n\t\t} else {\n\t\t\t// Timestamp float64\n\t\t\ttarget[position++] = 0xfb\n\t\t\ttargetView.setFloat64(position, seconds)\n\t\t\tposition += 8\n\t\t}\n\t}\n}, { // Set\n\ttag: 258, // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n\tencode(set, encode) {\n\t\tlet array = Array.from(set)\n\t\tencode(array)\n\t}\n}, { // Error\n\ttag: 27, // http://cbor.schmorp.de/generic-object\n\tencode(error, encode) {\n\t\tencode([ error.name, error.message ])\n\t}\n}, { // RegExp\n\ttag: 27, // http://cbor.schmorp.de/generic-object\n\tencode(regex, encode) {\n\t\tencode([ 'RegExp', regex.source, regex.flags ])\n\t}\n}, { // Tag\n\tgetTag(tag) {\n\t\treturn tag.tag\n\t},\n\tencode(tag, encode) {\n\t\tencode(tag.value)\n\t}\n}, { // ArrayBuffer\n\tencode(arrayBuffer, encode, makeRoom) {\n\t\twriteBuffer(arrayBuffer, makeRoom)\n\t}\n}, { // Uint8Array\n\tgetTag(typedArray) {\n\t\tif (typedArray.constructor === Uint8Array) {\n\t\t\tif (this.tagUint8Array || hasNodeBuffer && this.tagUint8Array !== false)\n\t\t\t\treturn 64;\n\t\t} // else no tag\n\t},\n\tencode(typedArray, encode, makeRoom) {\n\t\twriteBuffer(typedArray, makeRoom)\n\t}\n},\n\ttypedArrayEncoder(68, 1),\n\ttypedArrayEncoder(69, 2),\n\ttypedArrayEncoder(70, 4),\n\ttypedArrayEncoder(71, 8),\n\ttypedArrayEncoder(72, 1),\n\ttypedArrayEncoder(77, 2),\n\ttypedArrayEncoder(78, 4),\n\ttypedArrayEncoder(79, 8),\n\ttypedArrayEncoder(85, 4),\n\ttypedArrayEncoder(86, 8),\n{\n\tencode(sharedData, encode) { // write SharedData\n\t\tlet packedValues = sharedData.packedValues || []\n\t\tlet sharedStructures = sharedData.structures || []\n\t\tif (packedValues.values.length > 0) {\n\t\t\ttarget[position++] = 0xd8 // one-byte tag\n\t\t\ttarget[position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\twriteArrayHeader(4)\n\t\t\tlet valuesArray = packedValues.values\n\t\t\tencode(valuesArray)\n\t\t\twriteArrayHeader(0) // prefixes\n\t\t\twriteArrayHeader(0) // suffixes\n\t\t\tpackedObjectMap = Object.create(sharedPackedObjectMap || null)\n\t\t\tfor (let i = 0, l = valuesArray.length; i < l; i++) {\n\t\t\t\tpackedObjectMap[valuesArray[i]] = i\n\t\t\t}\n\t\t}\n\t\tif (sharedStructures) {\n\t\t\ttargetView.setUint32(position, 0xd9dffe00)\n\t\t\tposition += 3\n\t\t\tlet definitions = sharedStructures.slice(0)\n\t\t\tdefinitions.unshift(0xe000)\n\t\t\tdefinitions.push(new Tag(sharedData.version, 0x53687264))\n\t\t\tencode(definitions)\n\t\t} else\n\t\t\tencode(new Tag(sharedData.version, 0x53687264))\n\t\t}\n\t}]\nfunction typedArrayEncoder(tag, size) {\n\tif (!isLittleEndianMachine && size > 1)\n\t\ttag -= 4 // the big endian equivalents are 4 less\n\treturn {\n\t\ttag: tag,\n\t\tencode: function writeExtBuffer(typedArray, encode) {\n\t\t\tlet length = typedArray.byteLength\n\t\t\tlet offset = typedArray.byteOffset || 0\n\t\t\tlet buffer = typedArray.buffer || typedArray\n\t\t\tencode(hasNodeBuffer ? Buffer.from(buffer, offset, length) :\n\t\t\t\tnew Uint8Array(buffer, offset, length))\n\t\t}\n\t}\n}\nfunction writeBuffer(buffer, makeRoom) {\n\tlet length = buffer.byteLength\n\tif (length < 0x18) {\n\t\ttarget[position++] = 0x40 + length\n\t} else if (length < 0x100) {\n\t\ttarget[position++] = 0x58\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = 0x59\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = 0x5a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\tif (position + length >= target.length) {\n\t\tmakeRoom(position + length)\n\t}\n\t// if it is already a typed array (has an ArrayBuffer), use that, but if it is an ArrayBuffer itself,\n\t// must wrap it to set it.\n\ttarget.set(buffer.buffer ? buffer : new Uint8Array(buffer), position)\n\tposition += length\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId\n\tlet distanceToMove = idsToInsert.length * 2\n\tlet lastEnd = serialized.length - distanceToMove\n\tidsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1)\n\tfor (let id = 0; id < idsToInsert.length; id++) {\n\t\tlet referee = idsToInsert[id]\n\t\treferee.id = id\n\t\tfor (let position of referee.references) {\n\t\t\tserialized[position++] = id >> 8\n\t\t\tserialized[position] = id & 0xff\n\t\t}\n\t}\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n\t\tdistanceToMove -= 2\n\t\tlet position = offset + distanceToMove\n\t\tserialized[position++] = 0xd8\n\t\tserialized[position++] = 28 // http://cbor.schmorp.de/value-sharing\n\t\tlastEnd = offset\n\t}\n\treturn serialized\n}\nfunction writeBundles(start, encode) {\n\ttargetView.setUint32(bundledStrings.position + start, position - bundledStrings.position - start + 1) // the offset to bundle\n\tlet writeStrings = bundledStrings\n\tbundledStrings = null\n\tencode(writeStrings[0])\n\tencode(writeStrings[1])\n}\n\nexport function addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.encode)\n\t\t\tthrow new Error('Extension has no encode function')\n\t\textensionClasses.unshift(extension.Class)\n\t\textensions.unshift(extension)\n\t}\n\tdecodeAddExtension(extension)\n}\nlet defaultEncoder = new Encoder({ useRecords: false })\nexport const encode = defaultEncoder.encode\nexport const encodeAsIterable = defaultEncoder.encodeAsIterable\nexport const encodeAsAsyncIterable = defaultEncoder.encodeAsAsyncIterable\nexport { FLOAT32_OPTIONS } from './decode.js'\nimport { FLOAT32_OPTIONS } from './decode.js'\nexport const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS\nexport const REUSE_BUFFER_MODE = 512\nexport const RESET_BUFFER_MODE = 1024\nexport const THROW_ON_ITERABLE = 2048\n\n\n","let decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nlet src\nlet srcEnd\nlet position = 0\nlet alreadySet\nconst EMPTY_ARRAY = []\nconst LEGACY_RECORD_INLINE_ID = 105\nconst RECORD_DEFINITIONS_ID = 0xdffe\nconst RECORD_INLINE_ID = 0xdfff // temporary first-come first-serve tag // proposed tag: 0x7265 // 're'\nconst BUNDLED_STRINGS_ID = 0xdff9\nconst PACKED_TABLE_TAG_ID = 51\nconst PACKED_REFERENCE_TAG_ID = 6\nconst STOP_CODE = {}\nlet strings = EMPTY_ARRAY\nlet stringPosition = 0\nlet currentDecoder = {}\nlet currentStructures\nlet srcString\nlet srcStringStart = 0\nlet srcStringEnd = 0\nlet bundledStrings\nlet referenceMap\nlet currentExtensions = []\nlet currentExtensionRanges = []\nlet packedValues\nlet dataView\nlet restoreMapsAsObject\nlet defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nlet sequentialMode = false\nlet inlineObjectReadThreshold = 2;\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n\tnew Function('')\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity\n}\n\n\n\nexport class Decoder {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif ((options.keyMap || options._keyMap) && !options.useRecords) {\n\t\t\t\toptions.useRecords = false\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\t}\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.getStructures)\n\t\t\t\toptions.getShared = options.getStructures\n\t\t\tif (options.getShared && !options.structures)\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\tif (options.keyMap) {\n\t\t\t\tthis.mapKey = new Map()\n\t\t\t\tfor (let [k,v] of Object.entries(options.keyMap)) this.mapKey.set(v,k)\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\t/*\n\tdecodeKey(key) {\n\t\treturn this.keyMap\n\t\t\t? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key\n\t\t\t: key\n\t}\n\t*/\n\tdecodeKey(key) {\n\t\treturn this.keyMap ? this.mapKey.get(key) || key : key\n\t}\n\t\n\tencodeKey(key) {\n\t\treturn this.keyMap && this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key\n\t}\n\n\tencodeKeys(rec) {\n\t\tif (!this._keyMap) return rec\n\t\tlet map = new Map()\n\t\tfor (let [k,v] of Object.entries(rec)) map.set((this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k), v)\n\t\treturn map\n\t}\n\n\tdecodeKeys(map) {\n\t\tif (!this._keyMap || map.constructor.name != 'Map') return map\n\t\tif (!this._mapKey) {\n\t\t\tthis._mapKey = new Map()\n\t\t\tfor (let [k,v] of Object.entries(this._keyMap)) this._mapKey.set(v,k)\n\t\t}\n\t\tlet res = {}\n\t\t//map.forEach((v,k) => res[Object.keys(this._keyMap)[Object.values(this._keyMap).indexOf(k)] || k] = v)\n\t\tmap.forEach((v,k) => res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] =  v)\n\t\treturn res\n\t}\n\t\n\tmapDecode(source, end) {\n\t\n\t\tlet res = this.decode(source)\n\t\tif (this._keyMap) { \n\t\t\t//Experiemntal support for Optimised KeyMap  decoding \n\t\t\tswitch (res.constructor.name) {\n\t\t\t\tcase 'Array': return res.map(r => this.decodeKeys(r))\n\t\t\t\t//case 'Map': return this.decodeKeys(res)\n\t\t\t}\n\t\t}\n\t\treturn res\n\t}\n\n\tdecode(source, end) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this decode\n\t\t\treturn saveState(() => {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.decode(source, end) : Decoder.prototype.decode.call(defaultOptions, source, end)\n\t\t\t})\n\t\t}\n\t\tsrcEnd = end > -1 ? end : source.length\n\t\tposition = 0\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Decoder) {\n\t\t\tcurrentDecoder = this\n\t\t\tpackedValues = this.sharedValues &&\n\t\t\t\t(this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) :\n\t\t\t\tthis.sharedValues)\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead()\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentDecoder = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = []\n\t\t\tpackedValues = null\n\t\t}\n\t\treturn checkedRead()\n\t}\n\tdecodeMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tlet size = source.length\n\t\t\tsequentialMode = true\n\t\t\tlet value = this ? this.decode(source, size) : defaultDecoder.decode(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value) === false) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead()) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n}\nexport function getPosition() {\n\treturn position\n}\nexport function checkedRead() {\n\ttry {\n\t\tlet result = read()\n\t\tif (bundledStrings) {\n\t\t\tif (position >= bundledStrings.postBundlePosition) {\n\t\t\t\tlet error = new Error('Unexpected bundle position');\n\t\t\t\terror.incomplete = true;\n\t\t\t\tthrow error\n\t\t\t}\n\t\t\t// bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition;\n\t\t\tbundledStrings = null;\n\t\t}\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position > srcEnd) {\n\t\t\t// over read\n\t\t\tlet error = new Error('Unexpected end of CBOR data')\n\t\t\terror.incomplete = true\n\t\t\tthrow error\n\t\t} else if (!sequentialMode) {\n\t\t\tthrow new Error('Data read, but end of buffer not reached')\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer')) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nexport function read() {\n\tlet token = src[position++]\n\tlet majorType = token >> 5\n\ttoken = token & 0x1f\n\tif (token > 0x17) {\n\t\tswitch (token) {\n\t\t\tcase 0x18:\n\t\t\t\ttoken = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0x19:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\treturn getFloat16()\n\t\t\t\t}\n\t\t\t\ttoken = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0x1a:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\tlet value = dataView.getFloat32(position)\n\t\t\t\t\tif (currentDecoder.useFloat32 > 2) {\n\t\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t\t}\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\ttoken = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tcase 0x1b:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\tlet value = dataView.getFloat64(position)\n\t\t\t\t\tposition += 8\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\tif (majorType > 1) {\n\t\t\t\t\tif (dataView.getUint32(position) > 0)\n\t\t\t\t\t\tthrow new Error('JavaScript does not support arrays, maps, or strings with length over 4294967295')\n\t\t\t\t\ttoken = dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentDecoder.int64AsNumber) {\n\t\t\t\t\ttoken = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\ttoken += dataView.getUint32(position + 4)\n\t\t\t\t} else\n\t\t\t\t\ttoken = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\tbreak\n\t\t\tcase 0x1f: \n\t\t\t\t// indefinite length\n\t\t\t\tswitch(majorType) {\n\t\t\t\t\tcase 2: // byte string\n\t\t\t\t\tcase 3: // text string\n\t\t\t\t\t\tthrow new Error('Indefinite length not supported for byte or text strings')\n\t\t\t\t\tcase 4: // array\n\t\t\t\t\t\tlet array = []\n\t\t\t\t\t\tlet value, i = 0\n\t\t\t\t\t\twhile ((value = read()) != STOP_CODE) {\n\t\t\t\t\t\t\tarray[i++] = value\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn majorType == 4 ? array : majorType == 3 ? array.join('') : Buffer.concat(array)\n\t\t\t\t\tcase 5: // map\n\t\t\t\t\t\tlet key\n\t\t\t\t\t\tif (currentDecoder.mapsAsObjects) {\n\t\t\t\t\t\t\tlet object = {}\n\t\t\t\t\t\t\tif (currentDecoder.keyMap) while((key = read()) != STOP_CODE) object[safeKey(currentDecoder.decodeKey(key))] = read()\n\t\t\t\t\t\t\telse while ((key = read()) != STOP_CODE) object[safeKey(key)] = read()\n\t\t\t\t\t\t\treturn object\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (restoreMapsAsObject) {\n\t\t\t\t\t\t\t\tcurrentDecoder.mapsAsObjects = true\n\t\t\t\t\t\t\t\trestoreMapsAsObject = false\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet map = new Map()\n\t\t\t\t\t\t\tif (currentDecoder.keyMap) while((key = read()) != STOP_CODE) map.set(currentDecoder.decodeKey(key), read())\n\t\t\t\t\t\t\telse while ((key = read()) != STOP_CODE) map.set(key, read())\n\t\t\t\t\t\t\treturn map\n\t\t\t\t\t\t}\n\t\t\t\t\tcase 7:\n\t\t\t\t\t\treturn STOP_CODE\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error('Invalid major type for indefinite length ' + majorType)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown token ' + token)\n\t\t}\n\t}\n\tswitch (majorType) {\n\t\tcase 0: // positive int\n\t\t\treturn token\n\t\tcase 1: // negative int\n\t\t\treturn ~token\n\t\tcase 2: // buffer\n\t\t\treturn readBin(token)\n\t\tcase 3: // string\n\t\t\tif (srcStringEnd >= position) {\n\t\t\t\treturn srcString.slice(position - srcStringStart, (position += token) - srcStringStart)\n\t\t\t}\n\t\t\tif (srcStringEnd == 0 && srcEnd < 140 && token < 32) {\n\t\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\t\tlet string = token < 16 ? shortStringInJS(token) : longStringInJS(token)\n\t\t\t\tif (string != null)\n\t\t\t\t\treturn string\n\t\t\t}\n\t\t\treturn readFixedString(token)\n\t\tcase 4: // array\n\t\t\tlet array = new Array(token)\n\t\t  //if (currentDecoder.keyMap) for (let i = 0; i < token; i++) array[i] = currentDecoder.decodeKey(read())\t\n\t\t\t//else \n\t\t\tfor (let i = 0; i < token; i++) array[i] = read()\n\t\t\treturn array\n\t\tcase 5: // map\n\t\t\tif (currentDecoder.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tif (currentDecoder.keyMap) for (let i = 0; i < token; i++) object[safeKey(currentDecoder.decodeKey(read()))] = read()\n\t\t\t\telse for (let i = 0; i < token; i++) object[safeKey(read())] = read()\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tif (restoreMapsAsObject) {\n\t\t\t\t\tcurrentDecoder.mapsAsObjects = true\n\t\t\t\t\trestoreMapsAsObject = false\n\t\t\t\t}\n\t\t\t\tlet map = new Map()\n\t\t\t\tif (currentDecoder.keyMap) for (let i = 0; i < token; i++) map.set(currentDecoder.decodeKey(read()),read())\n\t\t\t\telse for (let i = 0; i < token; i++) map.set(read(), read())\n\t\t\t\treturn map\n\t\t\t}\n\t\tcase 6: // extension\n\t\t\tif (token >= BUNDLED_STRINGS_ID) {\n\t\t\t\tlet structure = currentStructures[token & 0x1fff] // check record structures first\n\t\t\t\t// At some point we may provide an option for dynamic tag assignment with a range like token >= 8 && (token < 16 || (token > 0x80 && token < 0xc0) || (token > 0x130 && token < 0x4000))\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) structure.read = createStructureReader(structure)\n\t\t\t\t\treturn structure.read()\n\t\t\t\t}\n\t\t\t\tif (token < 0x10000) {\n\t\t\t\t\tif (token == RECORD_INLINE_ID) { // we do a special check for this so that we can keep the\n\t\t\t\t\t\t// currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n\t\t\t\t\t\tlet length = readJustLength()\n\t\t\t\t\t\tlet id = read()\n\t\t\t\t\t\tlet structure = read()\n\t\t\t\t\t\trecordDefinition(id, structure)\n\t\t\t\t\t\tlet object = {}\n\t\t\t\t\t\tif (currentDecoder.keyMap) for (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\tlet key = currentDecoder.decodeKey(structure[i - 2])\n\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse for (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\tlet key = structure[i - 2]\n\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn object\n\t\t\t\t\t}\n\t\t\t\t\telse if (token == RECORD_DEFINITIONS_ID) {\n\t\t\t\t\t\tlet length = readJustLength()\n\t\t\t\t\t\tlet id = read()\n\t\t\t\t\t\tfor (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\trecordDefinition(id++, read())\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn read()\n\t\t\t\t\t} else if (token == BUNDLED_STRINGS_ID) {\n\t\t\t\t\t\treturn readBundleExt()\n\t\t\t\t\t}\n\t\t\t\t\tif (currentDecoder.getShared) {\n\t\t\t\t\t\tloadShared()\n\t\t\t\t\t\tstructure = currentStructures[token & 0x1fff]\n\t\t\t\t\t\tif (structure) {\n\t\t\t\t\t\t\tif (!structure.read)\n\t\t\t\t\t\t\t\tstructure.read = createStructureReader(structure)\n\t\t\t\t\t\t\treturn structure.read()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet extension = currentExtensions[token]\n\t\t\tif (extension) {\n\t\t\t\tif (extension.handlesRead)\n\t\t\t\t\treturn extension(read)\n\t\t\t\telse\n\t\t\t\t\treturn extension(read())\n\t\t\t} else {\n\t\t\t\tlet input = read()\n\t\t\t\tfor (let i = 0; i < currentExtensionRanges.length; i++) {\n\t\t\t\t\tlet value = currentExtensionRanges[i](token, input)\n\t\t\t\t\tif (value !== undefined)\n\t\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\treturn new Tag(input, token)\n\t\t\t}\n\t\tcase 7: // fixed value\n\t\t\tswitch (token) {\n\t\t\t\tcase 0x14: return false\n\t\t\t\tcase 0x15: return true\n\t\t\t\tcase 0x16: return null\n\t\t\t\tcase 0x17: return; // undefined\n\t\t\t\tcase 0x1f:\n\t\t\t\tdefault:\n\t\t\t\t\tlet packedValue = (packedValues || getPackedValues())[token]\n\t\t\t\t\tif (packedValue !== undefined)\n\t\t\t\t\t\treturn packedValue\n\t\t\t\t\tthrow new Error('Unknown token ' + token)\n\t\t\t}\n\t\tdefault: // negative int\n\t\t\tif (isNaN(token)) {\n\t\t\t\tlet error = new Error('Unexpected end of CBOR data')\n\t\t\t\terror.incomplete = true\n\t\t\t\tthrow error\n\t\t\t}\n\t\t\tthrow new Error('Unknown CBOR token ' + token)\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure) {\n\tfunction readObject() {\n\t\t// get the array size from the header\n\t\tlet length = src[position++]\n\t\t//let majorType = token >> 5\n\t\tlength = length & 0x1f\n\t\tif (length > 0x17) {\n\t\t\tswitch (length) {\n\t\t\t\tcase 0x18:\n\t\t\t\t\tlength = src[position++]\n\t\t\t\t\tbreak\n\t\t\t\tcase 0x19:\n\t\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\t\tposition += 2\n\t\t\t\t\tbreak\n\t\t\t\tcase 0x1a:\n\t\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\t\tposition += 4\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Expected array header, but got ' + src[position - 1])\n\t\t\t}\n\t\t}\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tlet compiledReader = this.compiledReader // first look to see if we have the fast compiled function\n\t\twhile(compiledReader) {\n\t\t\t// we have a fast compiled object literal reader\n\t\t\tif (compiledReader.propertyCount === length)\n\t\t\t\treturn compiledReader(read) // with the right length, so we use it\n\t\t\tcompiledReader = compiledReader.next // see if there is another reader with the right length\n\t\t}\n\t\tif (this.slowReads++ >= inlineObjectReadThreshold) { // create a fast compiled reader\n\t\t\tlet array = this.length == length ? this : this.slice(0, length)\n\t\t\tcompiledReader = currentDecoder.keyMap \n\t\t\t? new Function('r', 'return {' + array.map(k => currentDecoder.decodeKey(k)).map(k => validName.test(k) ? safeKey(k) + ':r()' : ('[' + JSON.stringify(k) + ']:r()')).join(',') + '}')\n\t\t\t: new Function('r', 'return {' + array.map(key => validName.test(key) ? safeKey(key) + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '}')\n\t\t\tif (this.compiledReader)\n\t\t\t\tcompiledReader.next = this.compiledReader // if there is an existing one, we store multiple readers as a linked list because it is usually pretty rare to have multiple readers (of different length) for the same structure\n\t\t\tcompiledReader.propertyCount = length\n\t\t\tthis.compiledReader = compiledReader\n\t\t\treturn compiledReader(read)\n\t\t}\n\t\tlet object = {}\n\t\tif (currentDecoder.keyMap) for (let i = 0; i < length; i++) object[safeKey(currentDecoder.decodeKey(this[i]))] = read()\n\t\telse for (let i = 0; i < length; i++) {\n\t\t\tobject[safeKey(this[i])] = read();\n\t\t}\n\t\treturn object\n\t}\n\tstructure.slowReads = 0\n\treturn readObject\n}\n\nfunction safeKey(key) {\n\treturn key === '__proto__' ? '__proto_' : key\n}\n\nlet readFixedString = readStringJS\nlet readString8 = readStringJS\nlet readString16 = readStringJS\nlet readString32 = readStringJS\n\nexport let isNativeAccelerationEnabled = false\nexport function setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet extraction = extractStrings(position, srcEnd, length, src)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nlet fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\tposition = start\n    \t\t\treturn\n    \t\t}\n    \t\tbytes[i] = byte\n    \t}\n    \treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readBin(length) {\n\treturn currentDecoder.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\treturn currentExtensions[type](src.subarray(position, position += length))\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nfunction getFloat16() {\n\tlet byte0 = src[position++]\n\tlet byte1 = src[position++]\n\tlet exponent = (byte0 & 0x7f) >> 2;\n\tif (exponent === 0x1f) { // specials\n\t\tif (byte1 || (byte0 & 3))\n\t\t\treturn NaN;\n\t\treturn (byte0 & 0x80) ? -Infinity : Infinity;\n\t}\n\tif (exponent === 0) { // sub-normals\n\t\t// significand with 10 fractional bits and divided by 2^14\n\t\tlet abs = (((byte0 & 3) << 8) | byte1) / (1 << 24)\n\t\treturn (byte0 & 0x80) ? -abs : abs\n\t}\n\n\tu8Array[3] = (byte0 & 0x80) | // sign bit\n\t\t((exponent >> 1) + 56) // 4 of 5 of the exponent bits, re-offset-ed\n\tu8Array[2] = ((byte0 & 7) << 5) | // last exponent bit and first two mantissa bits\n\t\t(byte1 >> 3) // next 5 bits of mantissa\n\tu8Array[1] = byte1 << 5; // last three bits of mantissa\n\tu8Array[0] = 0;\n\treturn f32Array[0];\n}\n\nlet keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length >= 0x60 && length < 0x78) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0x60\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn read()\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\nexport class Tag {\n\tconstructor(value, tag) {\n\t\tthis.value = value\n\t\tthis.tag = tag\n\t}\n}\n\ncurrentExtensions[0] = (dateString) => {\n\t// string date extension\n\treturn new Date(dateString)\n}\n\ncurrentExtensions[1] = (epochSec) => {\n\t// numeric date extension\n\treturn new Date(Math.round(epochSec * 1000))\n}\n\ncurrentExtensions[2] = (buffer) => {\n\t// bigint extension\n\tlet value = BigInt(0)\n\tfor (let i = 0, l = buffer.byteLength; i < l; i++) {\n\t\tvalue = BigInt(buffer[i]) + value << BigInt(8)\n\t}\n\treturn value\n}\n\ncurrentExtensions[3] = (buffer) => {\n\t// negative bigint extension\n\treturn BigInt(-1) - currentExtensions[2](buffer)\n}\ncurrentExtensions[4] = (fraction) => {\n\t// best to reparse to maintain accuracy\n\treturn +(fraction[1] + 'e' + fraction[0])\n}\n\ncurrentExtensions[5] = (fraction) => {\n\t// probably not sufficiently accurate\n\treturn fraction[1] * Math.exp(fraction[0] * Math.log(2))\n}\n\n// the registration of the record definition extension\nconst recordDefinition = (id, structure) => {\n\tid = id - 0xe000\n\tlet existingStructure = currentStructures[id]\n\tif (existingStructure && existingStructure.isShared) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\n\tstructure.read = createStructureReader(structure)\n}\ncurrentExtensions[LEGACY_RECORD_INLINE_ID] = (data) => {\n\tlet length = data.length\n\tlet structure = data[1]\n\trecordDefinition(data[0], structure)\n\tlet object = {}\n\tfor (let i = 2; i < length; i++) {\n\t\tlet key = structure[i - 2]\n\t\tobject[safeKey(key)] = data[i]\n\t}\n\treturn object\n}\ncurrentExtensions[14] = (value) => {\n\tif (bundledStrings)\n\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value)\n\treturn new Tag(value, 14)\n}\ncurrentExtensions[15] = (value) => {\n\tif (bundledStrings)\n\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\treturn new Tag(value, 15)\n}\nlet glbl = { Error, RegExp }\ncurrentExtensions[27] = (data) => { // http://cbor.schmorp.de/generic-object\n\treturn (glbl[data[0]] || Error)(data[1], data[2])\n}\nconst packedTable = (read) => {\n\tif (src[position++] != 0x84)\n\t\tthrow new Error('Packed values structure must be followed by a 4 element array')\n\tlet newPackedValues = read() // packed values\n\tpackedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues\n\tpackedValues.prefixes = read()\n\tpackedValues.suffixes = read()\n\treturn read() // read the rump\n}\npackedTable.handlesRead = true\ncurrentExtensions[51] = packedTable\n\ncurrentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => { // packed reference\n\tif (!packedValues) {\n\t\tif (currentDecoder.getShared)\n\t\t\tloadShared()\n\t\telse\n\t\t\treturn new Tag(data, PACKED_REFERENCE_TAG_ID)\n\t}\n\tif (typeof data == 'number')\n\t\treturn packedValues[16 + (data >= 0 ? 2 * data : (-2 * data - 1))]\n\tthrow new Error('No support for non-integer packed references yet')\n}\n\n// The following code is an incomplete implementation of http://cbor.schmorp.de/stringref\n// the real thing would need to implemennt more logic to populate the stringRefs table and\n// maintain a stack of stringRef \"namespaces\".\n//\n// currentExtensions[25] = (id) => {\n// \treturn stringRefs[id]\n// }\n// currentExtensions[256] = (read) => {\n// \tstringRefs = []\n// \ttry {\n// \t\treturn read()\n// \t} finally {\n// \t\tstringRefs = null\n// \t}\n// }\n// currentExtensions[256].handlesRead = true\n\ncurrentExtensions[28] = (read) => { \n\t// shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n\tif (!referenceMap) {\n\t\treferenceMap = new Map()\n\t\treferenceMap.id = 0\n\t}\n\tlet id = referenceMap.id++\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n\t// ahead past references to record structure definitions\n\tif ((token >> 5) == 4)\n\t\ttarget = []\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (refEntry.used) // there is a cycle, so we have to assign properties to original target\n\t\treturn Object.assign(target, targetProperties)\n\trefEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one\n\treturn targetProperties // no cycle, can just use the returned read object\n}\ncurrentExtensions[28].handlesRead = true\n\ncurrentExtensions[29] = (id) => {\n\t// sharedref http://cbor.schmorp.de/value-sharing (for structured clones)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[258] = (array) => new Set(array); // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n(currentExtensions[259] = (read) => {\n\t// https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec\n\t// for decoding as a standard Map\n\tif (currentDecoder.mapsAsObjects) {\n\t\tcurrentDecoder.mapsAsObjects = false\n\t\trestoreMapsAsObject = true\n\t}\n\treturn read()\n}).handlesRead = true\nfunction combine(a, b) {\n\tif (typeof a === 'string')\n\t\treturn a + b\n\tif (a instanceof Array)\n\t\treturn a.concat(b)\n\treturn Object.assign({}, a, b)\n}\nfunction getPackedValues() {\n\tif (!packedValues) {\n\t\tif (currentDecoder.getShared)\n\t\t\tloadShared()\n\t\telse\n\t\t\tthrow new Error('No packed values available')\n\t}\n\treturn packedValues\n}\nconst SHARED_DATA_TAG_ID = 0x53687264 // ascii 'Shrd'\ncurrentExtensionRanges.push((tag, input) => {\n\tif (tag >= 225 && tag <= 255)\n\t\treturn combine(getPackedValues().prefixes[tag - 224], input)\n\tif (tag >= 28704 && tag <= 32767)\n\t\treturn combine(getPackedValues().prefixes[tag - 28672], input)\n\tif (tag >= 1879052288 && tag <= 2147483647)\n\t\treturn combine(getPackedValues().prefixes[tag - 1879048192], input)\n\tif (tag >= 216 && tag <= 223)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 216])\n\tif (tag >= 27647 && tag <= 28671)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 27639])\n\tif (tag >= 1811940352 && tag <= 1879048191)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 1811939328])\n\tif (tag == SHARED_DATA_TAG_ID) {// we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n\t\treturn {\n\t\t\tpackedValues: packedValues,\n\t\t\tstructures: currentStructures.slice(0),\n\t\t\tversion: input,\n\t\t}\n\t}\n\tif (tag == 55799) // self-descriptive CBOR tag, just return input value\n\t\treturn input\n})\n\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1\nexport const typedArrays = [Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array,\n\ttypeof BigUint64Array == 'undefined' ? { name:'BigUint64Array' } : BigUint64Array, Int8Array, Int16Array, Int32Array,\n\ttypeof BigInt64Array == 'undefined' ? { name:'BigInt64Array' } : BigInt64Array, Float32Array, Float64Array]\nconst typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86]\nfor (let i = 0; i < typedArrays.length; i++) {\n\tregisterTypedArray(typedArrays[i], typedArrayTags[i])\n}\nfunction registerTypedArray(TypedArray, tag) {\n\tlet dvMethod = 'get' + TypedArray.name.slice(0, -5)\n\tlet bytesPerElement;\n\tif (typeof TypedArray === 'function')\n\t\tbytesPerElement = TypedArray.BYTES_PER_ELEMENT;\n\telse\n\t\tTypedArray = null;\n\tfor (let littleEndian = 0; littleEndian < 2; littleEndian++) {\n\t\tif (!littleEndian && bytesPerElement == 1)\n\t\t\tcontinue\n\t\tlet sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : 3\n\t\tcurrentExtensions[littleEndian ? tag : (tag - 4)] = (bytesPerElement == 1 || littleEndian == isLittleEndianMachine) ? (buffer) => {\n\t\t\tif (!TypedArray)\n\t\t\t\tthrow new Error('Could not find typed array for code ' + tag)\n\t\t\t// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned\n\t\t\treturn new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer)\n\t\t} : buffer => {\n\t\t\tif (!TypedArray)\n\t\t\t\tthrow new Error('Could not find typed array for code ' + tag)\n\t\t\tlet dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\t\t\tlet elements = buffer.length >> sizeShift\n\t\t\tlet ta = new TypedArray(elements)\n\t\t\tlet method = dv[dvMethod]\n\t\t\tfor (let i = 0; i < elements; i++) {\n\t\t\t\tta[i] = method.call(dv, i << sizeShift, littleEndian)\n\t\t\t}\n\t\t\treturn ta\n\t\t}\n\t}\n}\n\nfunction readBundleExt() {\n\tlet length = readJustLength()\n\tlet bundlePosition = position + read()\n\tfor (let i = 2; i < length; i++) {\n\t\t// skip past bundles that were already read\n\t\tlet bundleLength = readJustLength() // this will increment position, so must add to position afterwards\n\t\tposition += bundleLength\n\t}\n\tlet dataPosition = position\n\tposition = bundlePosition\n\tbundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\nfunction readJustLength() {\n\tlet token = src[position++] & 0x1f\n\tif (token > 0x17) {\n\t\tswitch (token) {\n\t\t\tcase 0x18:\n\t\t\t\ttoken = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0x19:\n\t\t\t\ttoken = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0x1a:\n\t\t\t\ttoken = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t}\n\t}\n\treturn token\n}\n\nfunction loadShared() {\n\tif (currentDecoder.getShared) {\n\t\tlet sharedData = saveState(() => {\n\t\t\t// save the state in case getShared modifies our buffer\n\t\t\tsrc = null\n\t\t\treturn currentDecoder.getShared()\n\t\t}) || {}\n\t\tlet updatedStructures = sharedData.structures || []\n\t\tcurrentDecoder.sharedVersion = sharedData.version\n\t\tpackedValues = currentDecoder.sharedValues = sharedData.packedValues\n\t\tif (currentStructures === true)\n\t\t\tcurrentDecoder.structures = currentStructures = updatedStructures\n\t\telse\n\t\t\tcurrentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures))\n\t}\n}\n\nfunction saveState(callback) {\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedDecoder = currentDecoder\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentDecoder = savedDecoder\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nexport function clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nexport function addExtension(extension) {\n\tcurrentExtensions[extension.tag] = extension.decode\n}\n\nexport const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nlet defaultDecoder = new Decoder({ useRecords: false })\nexport const decode = defaultDecoder.decode\nexport const decodeMultiple = defaultDecoder.decodeMultiple\nexport const FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nexport function roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\n","import { Encoder } from './encode.js'\nimport { Decoder } from './decode.js'\n\n/**\n * Given an Iterable first argument, returns an Iterable where each value is encoded as a Buffer\n * If the argument is only Async Iterable, the return value will be an Async Iterable.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object\n * @param {options} [options] - cbor-x Encoder options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator>}\n */\nexport function encodeIter (objectIterator, options = {}) {\n  if (!objectIterator || typeof objectIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable')\n  } else if (typeof objectIterator[Symbol.iterator] === 'function') {\n    return encodeIterSync(objectIterator, options)\n  } else if (typeof objectIterator.then === 'function' || typeof objectIterator[Symbol.asyncIterator] === 'function') {\n    return encodeIterAsync(objectIterator, options)\n  } else {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise')\n  }\n}\n\nfunction * encodeIterSync (objectIterator, options) {\n  const encoder = new Encoder(options)\n  for (const value of objectIterator) {\n    yield encoder.encode(value)\n  }\n}\n\nasync function * encodeIterAsync (objectIterator, options) {\n  const encoder = new Encoder(options)\n  for await (const value of objectIterator) {\n    yield encoder.encode(value)\n  }\n}\n\n/**\n * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects\n * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator\n * @param {object} [options] - Decoder options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator}\n */\nexport function decodeIter (bufferIterator, options = {}) {\n  if (!bufferIterator || typeof bufferIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise')\n  }\n\n  const decoder = new Decoder(options)\n  let incomplete\n  const parser = (chunk) => {\n    let yields\n    // if there's incomplete data from previous chunk, concatinate and try again\n    if (incomplete) {\n      chunk = Buffer.concat([incomplete, chunk])\n      incomplete = undefined\n    }\n\n    try {\n      yields = decoder.decodeMultiple(chunk)\n    } catch (err) {\n      if (err.incomplete) {\n        incomplete = chunk.slice(err.lastPosition)\n        yields = err.values\n      } else {\n        throw err\n      }\n    }\n    return yields\n  }\n\n  if (typeof bufferIterator[Symbol.iterator] === 'function') {\n    return (function * iter () {\n      for (const value of bufferIterator) {\n        yield * parser(value)\n      }\n    })()\n  } else if (typeof bufferIterator[Symbol.asyncIterator] === 'function') {\n    return (async function * iter () {\n      for await (const value of bufferIterator) {\n        yield * parser(value)\n      }\n    })()\n  }\n}\n"],"names":["$98f674c4cc22e340$var$decoder","$98f674c4cc22e340$var$src","$98f674c4cc22e340$var$srcEnd","$98f674c4cc22e340$var$currentStructures","$98f674c4cc22e340$var$srcString","$98f674c4cc22e340$var$bundledStrings","$98f674c4cc22e340$var$referenceMap","$98f674c4cc22e340$var$packedValues","$98f674c4cc22e340$var$dataView","$98f674c4cc22e340$var$restoreMapsAsObject","$100754e509e7a4e7$var$textEncoder","$100754e509e7a4e7$var$extensions","$100754e509e7a4e7$var$extensionClasses","$100754e509e7a4e7$var$throwOnIterable","$100754e509e7a4e7$var$target","$100754e509e7a4e7$var$targetView","$100754e509e7a4e7$var$safeEnd","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$b68ef8ad985e69ce$export$72aa44612e2200cd","$aGTqB","$brJ7I","DataConnection","constructor","peerId","provider","options","reliable","_CHUNK_SIZE","_splitStream","TransformStream","transform","chunk","controller","split","length","enqueue","subarray","_rawSendStream","WritableStream","write","openEvent","Promise","resolve","dataChannel","addEventListener","once","bufferedAmount","MAX_BUFFERED_AMOUNT","byteLength","send","default","error","connectionId","close","writer","writable","getWriter","_rawReadStream","ReadableStream","start","data","readable","pipeTo","_initializeDataChannel","dc","binaryType","bufferedAmountLowThreshold","$55e90223fe532944$export$2e2bcd8739ae039","LogLevel","$55e90223fe532944$export$243e62d78d3b544d","logLevel","_logLevel","log","args","_print","warn","setLogFunction","fn","rest","copy","i","name","message","console","$f7363ab6888d1e18$export$d365f7ad9d7df9c9","$eEr5Q","$3pPW3","$kRc3N","$9Ek5E","BaseConnection","_","ID_PREFIX","_1","type","ConnectionType","Data","randomToken","label","_negotiator","Negotiator","startConnection","_payload","originator","onopen","_open","emit","onmessage","onclose","peer","flush","__peerData","cleanup","_removeConnection","open","chunked","emitError","DataConnectionErrorType","NotOpenYet","_send","handleMessage","payload","ServerMessageType","Answer","handleSDP","sdp","Candidate","handleCandidate","candidate","$ee2f7acfd22ad8cb$export$89e6bb5ad64bf4a","connection","peerConnection","_startPeerConnection","Media","_stream","_addTracksToConnection","dataConnection","config","ordered","createDataChannel","_makeOffer","RTCPeerConnection","_setupListeners","connectionType","onicecandidate","evt","socket","dst","oniceconnectionstatechange","iceConnectionState","BaseConnectionErrorType","NegotiationFailed","ConnectionClosed","ondatachannel","channel","getConnection","ontrack","stream","streams","_addStreamToMediaConnection","peerConnectionNotClosed","signalingState","dataChannelNotClosed","readyState","offer","createOffer","constraints","sdpTransform","setLocalDescription","metadata","serialization","Offer","PeerErrorType","WebRTC","err_1","_makeAnswer","answer","createAnswer","RTCSessionDescription","setRemoteDescription","self","ice","addIceCandidate","addTrack","getTracks","forEach","track","mediaConnection","addStream","$e07633d19f7426e9$export$3157d57b4135e3bc","$e07633d19f7426e9$export$9547aaa2e39030ff","$e07633d19f7426e9$export$7974935686149686","$e07633d19f7426e9$export$49ae800c114df41d","$e07633d19f7426e9$export$89f507cf986a947","$e07633d19f7426e9$export$3b5c4a4b6354f023","$e07633d19f7426e9$export$adb4a1754da6f10d","SerializationType","SocketEventType","$76eedc1a03766751$export$23a2a68283c24d80","$8edWV","EventEmitterWithError","$428dbabfb6f47b54$export$6a678e589c8a4542","$2b5HH","EventEmitter","$428dbabfb6f47b54$export$98871882f492de82","assign","$1961087dd546fd56$var$has","prototype","hasOwnProperty","$1961087dd546fd56$var$prefix","$1961087dd546fd56$var$Events","$1961087dd546fd56$var$EE","context","$1961087dd546fd56$var$addListener","emitter","event","TypeError","listener","_events","push","_eventsCount","$1961087dd546fd56$var$clearEvent","$1961087dd546fd56$var$EventEmitter","create","__proto__","eventNames","events","names","slice","getOwnPropertySymbols","concat","listeners","handlers","l","ee","Array","listenerCount","a1","a2","a3","a4","a5","len","arguments","removeListener","undefined","apply","j","on","removeAllListeners","off","addListener","prefixed","$eb916fa843978df9$export$4e61f672936bec77","Math","random","toString","$5L6jO","$98f674c4cc22e340$require$Buffer","Buffer","TextDecoder","$98f674c4cc22e340$var$position","$98f674c4cc22e340$var$EMPTY_ARRAY","$98f674c4cc22e340$var$STOP_CODE","$98f674c4cc22e340$var$strings","$98f674c4cc22e340$var$stringPosition","$98f674c4cc22e340$var$currentDecoder","$98f674c4cc22e340$var$srcStringStart","$98f674c4cc22e340$var$srcStringEnd","$98f674c4cc22e340$var$currentExtensions","$98f674c4cc22e340$var$currentExtensionRanges","$98f674c4cc22e340$var$defaultOptions","useRecords","mapsAsObjects","$98f674c4cc22e340$var$sequentialMode","$98f674c4cc22e340$var$inlineObjectReadThreshold","Function","Infinity","$98f674c4cc22e340$export$f9de6ca0bc043724","keyMap","_keyMap","getStructures","getShared","structures","uninitialized","k","mapKey","Map","entries","decodeKey","key","encodeKey","encodeKeys","rec","map","decodeKeys","_mapKey","res","$98f674c4cc22e340$var$safeKey","has","mapDecode","source","end","decode","r","$98f674c4cc22e340$var$saveState","$98f674c4cc22e340$export$e6f020404d5b6c15","dataView","DataView","buffer","byteOffset","Uint8Array","sharedValues","pack","maxPrivatePackedValues","$98f674c4cc22e340$export$8cb90b5f58dd32e2","decodeMultiple","values","lastPosition","size","value","$98f674c4cc22e340$var$defaultDecoder","result","$98f674c4cc22e340$export$aafa59e2e03f2942","postBundlePosition","incomplete","RangeError","startsWith","token","majorType","$98f674c4cc22e340$var$getFloat16","byte0","byte1","exponent","NaN","abs","$98f674c4cc22e340$var$u8Array","$98f674c4cc22e340$var$f32Array","getUint16","getFloat32","useFloat32","multiplier","$98f674c4cc22e340$export$c652a5bbb6be7a36","getUint32","getFloat64","int64AsNumber","getBigUint64","array","join","object","copyBuffers","string","$98f674c4cc22e340$var$shortStringInJS","$98f674c4cc22e340$var$longStringInJS","bytes","byte","$98f674c4cc22e340$var$fromCharCode","String","$98f674c4cc22e340$var$readFixedString","array1","structure","read","$98f674c4cc22e340$var$createStructureReader","$98f674c4cc22e340$var$readJustLength","$98f674c4cc22e340$var$recordDefinition","$98f674c4cc22e340$var$readBundleExt","bundlePosition","bundleLength","dataPosition","$98f674c4cc22e340$var$readStringJS","position0","position1","$98f674c4cc22e340$var$loadShared","extension","handlesRead","input","$98f674c4cc22e340$export$3288d34c523a1192","packedValue","$98f674c4cc22e340$var$getPackedValues","isNaN","$98f674c4cc22e340$var$validName","slowReads","compiledReader","propertyCount","next","test","JSON","stringify","units","byte2","byte3","unit","fromCharCode","a","b","c","d","f","g","h","m","o","Float32Array","tag","dateString","Date","epochSec","round","BigInt","fraction","exp","existingStructure","isShared","restoreStructures","$98f674c4cc22e340$var$glbl","RegExp","$98f674c4cc22e340$var$packedTable","newPackedValues","prefixes","suffixes","$98f674c4cc22e340$var$combine","target","refEntry","targetProperties","used","Set","packedValues","version","$98f674c4cc22e340$var$isLittleEndianMachine","Uint16Array","$98f674c4cc22e340$export$aae3eaec024a56b7","Uint8ClampedArray","Uint32Array","BigUint64Array","Int8Array","Int16Array","Int32Array","BigInt64Array","Float64Array","$98f674c4cc22e340$var$typedArrayTags","$98f674c4cc22e340$var$registerTypedArray","TypedArray","bytesPerElement","dvMethod","BYTES_PER_ELEMENT","littleEndian","sizeShift","dv","elements","ta","method","sharedData","updatedStructures","sharedVersion","splice","callback","savedSrcEnd","savedPosition","savedStringPosition","savedSrcStringStart","savedSrcStringEnd","savedSrcString","savedStrings","savedReferenceMap","savedBundledStrings","savedSrc","savedStructures","savedDecoder","savedSequentialMode","floor","TextEncoder","$100754e509e7a4e7$var$Buffer","$100754e509e7a4e7$var$hasNodeBuffer","$100754e509e7a4e7$var$ByteArrayAllocate","allocUnsafeSlow","$100754e509e7a4e7$var$ByteArray","$100754e509e7a4e7$var$MAX_BUFFER_SIZE","$100754e509e7a4e7$var$position","$100754e509e7a4e7$var$bundledStrings","$100754e509e7a4e7$var$hasNonLatin","$100754e509e7a4e7$var$RECORD_SYMBOL","Symbol","$100754e509e7a4e7$export$a50aceb0e02a00aa","sharedStructures","hasSharedUpdate","referenceMap","sharedPackedObjectMap1","offset","encodeUtf8","utf8Write","position","maxBytes","encodeInto","written","encoder","hasSharedStructures","saveStructures","maxSharedStructures","isSequential","sequential","saveShared","samplingPackedValues","packedObjectMap1","recordIdsToRemove","transitionsCount","serializationsSinceTransitionRebuild","mapEncode","encodeOptions","_mapped","encode","$100754e509e7a4e7$export$d41ac1453288b342","useSelfDescribedHeader","setUint32","structuredClone","bundleStrings","sharedStructuresLength","transitions","keys","nextTransition","transition","nextId","maxValues","objectMap","$100754e509e7a4e7$var$findRepetitiveStrings","packedStatus","count","status","includeKeys","$100754e509e7a4e7$var$writeArrayHeader","valuesArray","$100754e509e7a4e7$export$e724ae76933ea297","$100754e509e7a4e7$var$writeBundles","idsToInsert","makeRoom","serialized","$100754e509e7a4e7$var$insertIds","distanceToMove","lastEnd","sort","referee","references","pop","copyWithin","returnBuffer","updateSharedData","$100754e509e7a4e7$export$5687accb6effa257","findCommonStringsToPack","threshold","headerSize","packedPosition","strLength","extStart","twoByte","c1","c2","strPosition","charCodeAt","alwaysUseFloat","xShifted","setFloat32","setFloat64","setUint16","writeObject","useTag259ForMaps","entryValue","getTag","iterator","iteratorNotHandled","entry","asyncIterator","$100754e509e7a4e7$var$isBlob","useToJSON","toJSON","json","setBigUint64","largeBigIntToFloat","Number","variableMapSize","vals","safePrototype","objectOffset","parentRecordId","newTransitions","recordId","__keys__","$100754e509e7a4e7$var$MAX_STRUCTURES","shift","newSize","min","max","newBuffer","chunkThreshold","continuedChunkThreshold","encodeObjectAsIterable","iterateProperties","finalIterable","$100754e509e7a4e7$var$writeEntityLength","tryEncode","element","restartEncoding","restart","startEncoding","encodeIterable","encodeObjectAsAsyncIterable","encodedValue","reader","getReader","done","asyncValue","async","encodeAsIterable","encodeAsAsyncIterable","useBuffer","clearSharedData","lastVersion","structuresCopy","$100754e509e7a4e7$var$SharedData","saveResults","existingShared","majorValue","$100754e509e7a4e7$var$BlobConstructor","Blob","toStringTag","$100754e509e7a4e7$var$isLittleEndianMachine","$100754e509e7a4e7$var$typedArrayEncoder","typedArray","from","$100754e509e7a4e7$var$writeBuffer","writeStrings","ArrayBuffer","date","seconds","getTime","useTimestamp32","getMilliseconds","regex","flags","arrayBuffer","tagUint8Array","packedObjectMap","sharedPackedObjectMap","definitions","unshift","$100754e509e7a4e7$var$defaultEncoder","NEVER","$100754e509e7a4e7$export$96c94437c95d7862","ALWAYS","$100754e509e7a4e7$export$9252627518dcde93","DECIMAL_ROUND","$100754e509e7a4e7$export$50de32e2440ab0bf","DECIMAL_FIT","$100754e509e7a4e7$export$fa7c7714126eb380","$hBa25","$31a20e1f2ee0e410$var$NullValue","for","$31a20e1f2ee0e410$var$iterateOver","releaseLock","$31a20e1f2ee0e410$export$7e9583c3c8a0a2cc","StreamConnection","_encoder","_decoder","_decoderStream","abchunk","_inc","$31a20e1f2ee0e410$var$concatUint8Array","buffer1","buffer2","tmp","msg","Cbor"],"version":3,"file":"serializer.cbor.mjs.map"}